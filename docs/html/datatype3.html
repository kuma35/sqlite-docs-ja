<!DOCTYPE html>
<html><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="sqlite.css" rel="stylesheet">
<title>Datatypes In SQLite</title>

<!-- path= -->
</head>
<body>
<div class=nosearch>
<a href="index.html">
<img class="logo" src="images/sqlite370_banner.gif" alt="SQLite" border="0">
</a>
<div><!-- IE hack to prevent disappearing logo -->
</div>
<div class="tagline desktoponly">
Small. Fast. Reliable.<br>Choose any three.
</div>
<div class="menu mainmenu">
<ul>
<li><a href="index.html">Home</a>
<li class='mobileonly'><a href="javascript:void(0)" onclick='toggle_div("submenu")'>Menu</a>
<li class='wideonly'><a href='about.html'>About</a>
<li class='desktoponly'><a href="docs.html">Documentation</a>
<li class='desktoponly'><a href="download.html">Download</a>
<li class='wideonly'><a href='copyright.html'>License</a>
<li class='desktoponly'><a href="support.html">Support</a>
<li class='desktoponly'><a href="prosupport.html">Purchase</a>
<li class='search' id='search_menubutton'>
<a href="javascript:void(0)" onclick='toggle_search()'>Search</a>
</ul>
</div>
<div class="menu submenu" id="submenu">
<ul>
<li><a href='about.html'>About</a>
<li><a href='docs.html'>Documentation</a>
<li><a href='download.html'>Download</a>
<li><a href='support.html'>Support</a>
<li><a href='prosupport.html'>Purchase</a>
</ul>
</div>
<div class="searchmenu" id="searchmenu">
<form method="GET" action="search">
<select name="s" id="searchtype">
<option value="d">Search Documentation</option>
<option value="c">Search Changelog</option>
</select> <input type="text" name="q" id="searchbox" value=""/> <input
type="submit" value="Go"/>
</form>
</div>
</div>
<script>
function toggle_div(nm) { var w = document.getElementById(nm); if(
w.style.display=="block" ){ w.style.display = "none"; }else{ w.style.display
= "block"; } } function toggle_search() { var w =
document.getElementById("searchmenu"); if( w.style.display=="block" ){
w.style.display = "none"; } else { w.style.display = "block";
setTimeout(function(){ document.getElementById("searchbox").focus()  }, 30);
} } function div_off(nm){document.getElementById(nm).style.display="none";}
window.onbeforeunload = function(e){div_off("submenu");} /* Disable the
Search feature if we are not operating from CGI, since */ /* Search is
accomplished using CGI and will not work without it. */ if( !location.origin
|| !location.origin.match || !location.origin.match(/http/) ){
document.getElementById("search_menubutton").style.display = "none"; } /*
Used by the Hide/Show button beside syntax diagrams, to toggle the */
function hideorshow(btn,obj){ var x = document.getElementById(obj); var b =
document.getElementById(btn); if( x.style.display!='none' ){ x.style.display
= 'none'; b.innerHTML='show'; }else{ x.style.display = '';
b.innerHTML='hide'; } return false; } var antiRobot = 0; function
antiRobotGo(){ if( antiRobot!=3 ) return; antiRobot = 7; var j =
document.getElementById("mtimelink"); if(j && j.hasAttribute("data-href"))
j.href=j.getAttribute("data-href"); } function antiRobotDefense(){
document.body.onmousedown=function(){ antiRobot |= 2; antiRobotGo();
document.body.onmousedown=null; } document.body.onmousemove=function(){
antiRobot |= 2; antiRobotGo(); document.body.onmousemove=null; }
setTimeout(function(){ antiRobot |= 1; antiRobotGo(); }, 100)
antiRobotGo(); } antiRobotDefense();
</script>
<div class=fancy>
<div class=nosearch>
<div class="fancy_title">
Datatypes In SQLite
</div>
<div class="fancy_toc">
<a onclick="toggle_toc()"> <span class="fancy_toc_mark"
id="toc_mk">&#x25ba;</span> Table Of Contents </a>
<div id="toc_sub"><div class="fancy-toc1"><a href="#datatypes_in_sqlite">1. Datatypes In SQLite</a></div>
<div class="fancy-toc1"><a href="#storage_classes_and_datatypes">2. 格納クラス(Storage Classes)とデータ型</a></div>
<div class="fancy-toc2"><a href="#boolean_datatype">2.1. Boolean Datatype</a></div>
<div class="fancy-toc2"><a href="#date_and_time_datatype">2.2. Date and Time Datatype</a></div>
<div class="fancy-toc1"><a href="#type_affinity">3. 型好相性(Affinity)</a></div>
<div class="fancy-toc2"><a href="#determination_of_column_affinity">3.1. 列好相性(Column
Affinity)の決定</a></div>
<div class="fancy-toc3"><a href="#affinity_name_examples">3.1.1. 好相性名の例</a></div>
<div class="fancy-toc2"><a href="#affinity_of_expressions">3.2. 式の好相性</a></div>
<div class="fancy-toc2"><a href="#column_affinity_for_views_and_subqueries">3.3. View とサブクエリの
列好相性</a></div>
<div class="fancy-toc3"><a href="#column_affinity_for_compound_views">3.3.1. 複合Viewの列好相性</a></div>
<div class="fancy-toc2"><a href="#column_affinity_behavior_example">3.4. 列好相性の振る舞いの例</a></div>
<div class="fancy-toc1"><a href="#comparison_expressions">4. 比較式</a></div>
<div class="fancy-toc2"><a href="#sort_order">4.1. 並べ替え順</a></div>
<div class="fancy-toc2"><a href="#type_conversions_prior_to_comparison">4.2. 比較前の型変換</a></div>
<div class="fancy-toc2"><a href="#comparison_example">4.3. 比較の例</a></div>
<div class="fancy-toc1"><a href="#operators">5. 演算子</a></div>
<div class="fancy-toc1"><a
href="#sorting_grouping_and_compound_selects">6.
並べ替え(sorting)と集計(grouping)と複合(compound)SELECT</a></div>
<div class="fancy-toc1"><a href="#collating_sequences">7. 照合シーケンス(Collating Sequences)</a></div>
<div class="fancy-toc2"><a href="#assigning_collating_sequences_from_sql">7.1. SQL
から照合シーケンスを割り当てる</a></div>
<div class="fancy-toc2"><a href="#collation_sequence_examples">7.2. 照合シーケンス(Collation
Sequence)の例</a></div>
</div>
</div>
<script>
function toggle_toc(){ var sub = document.getElementById("toc_sub")  var mk
= document.getElementById("toc_mk")  if( sub.style.display!="block" ){
sub.style.display = "block"; mk.innerHTML = "&#x25bc;"; } else {
sub.style.display = "none"; mk.innerHTML = "&#x25ba;"; } }
</script>
</div>





<h1 id="datatypes_in_sqlite"><span>1. </span>Datatypes In SQLite</h1>
<p>ほとんどの SQL データベース・エンジン (私たちが知る限り、SQLite 以外のすべての SQL データベース・エンジン) は、
静的で厳格な型付けを使用します。 静的型付けでは、 値のデータ型はコンテナ(値が格納される特定の列)によって決定されます。</p>

<p>SQLite は、 より一般的な動的型システムを使用します。 SQLite では、 値のデータ型はコンテナではなく、 値自体に関連付けられます。
SQLite の動的型システムは、 静的に型指定されたデータベースで機能する SQL ステートメントが SQLite
でも同じように機能するという意味で、 他のデータベース・エンジンの、 より一般的な静的型システムと下位互換性があります。 ただし、SQLite
の動的型付けにより、 従来の厳格に型付けされたデータベースでは不可能なことを行うことができます。 <a
href="flextypegood.html">柔軟な型付けは SQLite の機能</a>であり、 バグではありません。</p>

<p>Update: バージョン 3.37.0 (2021-11-27) の時点で、 SQLite は厳格な型の強制を行う <a
href="stricttables.html">STRICT テーブル</a> を提供します。 そのようなことを好む開発者向けです。 <a
name="storageclasses"></a>

</p><h1 id="storage_classes_and_datatypes"><span>2. </span>格納クラス(Storage Classes)とデータ型</h1>

<p>SQLite データベースに格納された(またはデータベース・エンジンによって操作された)各値には、 以下の格納クラス(storage
classes)のいずれかがあります:</p>
<ul>
  <li><b>NULL</b>: 値は NULL 値です。

  </li><li><b>INTEGER</b>: 値は符号付き整数で、 値の大きさ(magnitude )に応じて 0、1、2、3、4、6、8
バイトのいずれかのサイズで格納されます。

  </li><li><b>REAL</b>: 値は浮動小数点値で、 8 バイトの IEEE 浮動小数点数として格納されます。

  </li><li><b>TEXT</b>: 値はテキスト文字列(string)で、 データベースのエンコーディング (UTF-8 または UTF-16BE または
UTF-16LE) を使用して保存されます。

  </li><li><b>BLOB</b>: 値はデータの塊(blob)であり、 入力されたとおりに保存されます。
</li></ul>

<p>格納クラス(storage class)は、 データ型よりも一般的です。  たとえば、 INTEGER 格納クラスには、 異なる長さの 7
つの異なる整数データ型が含まれています。 <a href="fileformat2.html#record_format">これにより、
ディスク上で違いが生じます</a>。 しかし、 その INTEGER 値がディスクから読み取られ、
処理のためにメモリに読み込まれるとすぐに、最も一般的なデータ型(8バイトの符号付き整数)に変換されます。 そのため、
ほとんどの場合、「格納クラス」(storage class)は「データ型」と区別がつかず、 ２つの用語は同じ意味で使用できます。</p>

<p><a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>  列を除く SQLite
バージョン 3 データベースの任意の列を使用して、 任意の格納クラス(storage class)の値を格納できます。</p>

<p>SQL ステートメント・テキストに埋め込まれたリテラルであるか、 <a href="c3ref/stmt.html">プリ・コンパイルされた SQL
ステートメント</a>に結び付けされた(boun) <a
href="lang_expr.html#varparam">パラメーター</a>であるかに関係なく、 SQL ステートメント内のすべての値には、
暗黙的な格納クラス(implicit storage class)があります。 以下に説明する状況では、 データベース・エンジンは、
クエリの実行中に数値格納クラス (INTEGER や REAL) と TEXT の間で値を変換する場合があります。 
</p>

<a name="boolean"></a>

<h2 id="boolean_datatype"><span>2.1. </span>Boolean Datatype</h2>

<p>SQLite には、 個別の Boolean 格納クラスはありません。 代わりに、 ブール値は整数 0 (false) や 1 (true)
として格納されます。</p>

<p>バージョン 3.23.0 (2018-04-02) の時点で、 SQLite はキーワード "TRUE" と "FALSE" を認識しますが、
これらのキーワードは実際には整数リテラル 1 と 0 の代替記述(alternative spellings)にすぎません。 <a
name="datetime"></a>

</p><h2 id="date_and_time_datatype"><span>2.2. </span>Date and Time Datatype</h2>

<p>SQLite には、 日付や時刻を格納するための格納クラスが用意されていません。  代わりに、SQLite の組み込みの <a
href="lang_datefunc.html">日付と時刻関数</a> は、 日付と時刻を TEXT または REAL または INTEGER
値として格納できます。</p>

<ul>
<li><b>TEXT</b> 値では ISO8601 文字列 ("YYYY-MM-DD HH:MM:SS.SSS") として格納されます。
</li><li><b>REAL</b> はユリウス通日数(Julian day numbers)として、 先発グレゴリオ暦では紀元前 4714 年 11 月 24
日のグリニッジ正午からの日数です。(訳注: wikipedia より;
ユリウス通日はユリウス暦紀元前4713年1月1日（先発グレゴリオ暦では紀元前4714年11月24日、 西暦
-4713年11月24日）の正午（世界時）を元期（＝0日目）とし、 日の単位で数える。
ユリウス通日は天文時の伝統に従い、日の起点は正午である。したがって、世界時の正午に日数（の整数部分）が増加する。
単にユリウス日（ユリウスび）ともいう。時刻値を示すために一般には小数が付けられる。
例えば、協定世界時（UTC）での2023年3月20日16:42のユリウス通日の値は、おおむね2460024.2である。 (
https://ja.wikipedia.org/wiki/ユリウス通日 )
</li><li><b>INTEGER</b> 値 は Unix 時間として(Unix Time)、 1970-01-01 00:00:00 UTC からの秒数です。
</li></ul>

<p>アプリケーションは、 これらの形式のいずれかで日付と時刻を保存することを選択し、 組み込みの <a
href="lang_datefunc.html">日付と時刻関数</a> を使用して、 これらの形式の間で自由に変換できます。</p>


<a name="affinity"></a>

<h1 id="type_affinity"><span>3. </span>型好相性(Affinity)</h1>

<p>
厳密な型指定を使用する SQL データベース・エンジンは、 通常、 値を適切なデータ型に自動的に変換しようとします。 以下について考えてみましょう:

</p><blockquote><pre>
CREATE TABLE t1(a INT, b VARCHAR(10));
INSERT INTO t1(a,b) VALUES('123',456);
</pre></blockquote>

<p>
厳密に型指定されたデータベースは、 挿入を行う前に文字列 '123' を整数 123 に、 整数 456 を文字列 '456' に変換します。

</p><p>
SQLite と他のデータベース・エンジンとの互換性を最大限に高め、 上記の例が他の SQL データベース・エンジンと同様に SQLite
でも機能するように、 SQLite は列の「型好相性」(type
affinity;その列に一番相性がいい(高い)格納クラス)の概念をサポートしています。 列の型好相性は、 その列に格納されるデータの推奨される型です。
ここで重要な点は、 型は必須ではなく推奨されるということです。 任意の列には、 任意の型のデータを格納できます。 選択肢が与えられた一部の列は、
ある格納クラスを別の格納クラスよりも好んで使用するだけです。  列の優先格納クラスは、「好相性」(affinity;アフィニティ)と呼ばれます。
</p>

<p>SQLite 3 データベースの各列には、 以下の型好相性(type affinities)のいずれかが割り当てられます:</p>
<ul>
	<li>TEXT</li>
	<li>NUMERIC</li>
	<li>INTEGER</li>
        <li>REAL</li>
	<li>BLOB</li>
</ul>

<p>(歴史的なメモ:  "BLOB" 型の好相性は、 以前は "NONE" と呼ばれていました。しかし、この用語は 「好相性無し」と混同しやすいため、
名前が変更されました。)

</p><p>TEXT 好相性を持つ列には、 格納クラス NULL または TEXT または BLOB を使用してすべてのデータが格納されます。 数値データが
TEXT 好相性を持つ列に挿入されると、 格納される前にテキスト形式に変換されます。</p>

<p>NUMERIC 好相性を持つ列には、 5つの格納クラスすべてを使用する値が含まれる場合があります。 テキスト・データが NUMERIC
列に挿入されると、 テキストが整形式の整数または実数リテラルである場合、 テキストの格納クラスは (優先順に) INTEGER または REAL
に変換されます。 TEXT 値が整形式の整数リテラルであり、 大きすぎて 64 ビットの符号付き整数に収まらない場合は、 REAL に変換されます。
TEXT と REAL の格納クラス間の変換では、 数値の最初の 15 桁の有効数字のみが保持されます。 TEXT
値が整形式の整数または実数リテラルでない場合、 値は TEXT として格納されます。 ここでは、16 進数の整数リテラルは整形式とは見なされず、TEXT
として格納されます。 (これは、16 進整数リテラルが最初に SQLite に導入された<a
href="releaselog/3_8_6.html">バージョン 3.8.6</a>(2014-08-15)より前のバージョンの SQLite
との歴史的な互換性のために行われます。)  正確に整数として表現できる浮動小数点値が NUMERIC 好相性を持つ列に挿入されると、
その値は整数に変換されます。 NULL または BLOB 値の変換は試行されません。</p>

<p>文字列(string)は、 小数点 および/また は指数表記のある浮動小数点リテラルのように見えるかもしれませんが、 値が整数として表現できる限り、
NUMERIC 好相性はそれを整数に変換します。 したがって、 文字列 '3.0e+5' は、 浮動小数点値 300000.0 としてではなく、 整数
300000 として NUMERIC 好相性を持つ列に格納されます。</p>

<p>INTEGER 好相性を使用する列は、 NUMERIC アフィニティを使用する列と同一に振る舞います。 INTEGER と NUMERIC
の好相性の違いは、 <a href="lang_expr.html#castexpr">CAST 式</a>でのみ明らかです。 式 "CAST(4.0
AS INT)" は整数 4 を返しますが、"CAST( 4.0 AS NUMERIC)" は、 値を浮動小数点 4.0 のままにします。</p>

<p>REAL 好相性を持つ列は、 整数値を強制的に浮動小数点表現にする点を除いて、 NUMERIC 好相性を持つ列のように振る舞います。
(内部の最適化として、 小数部分を持たず、 REAL 好相性を持つ列に格納された小さな浮動小数点値は、
使用するスペースを少なくするために整数としてディスクに書き込まれ、 値が読み取られると自動的に浮動小数点に変換されます。 最適化は SQL
レベルでは全く見えず、 データベース・ファイルの生のビットを調べることによってのみ検出できます。)</p>

<p>BLOB 好相性を持つ列は、 ある格納クラスを別の格納クラスより優先することはなく、 かつ、
ある格納クラスから別の格納クラスにデータを強制する試みは行われません。</p>

<a name="affname"></a>

<h2 id="determination_of_column_affinity"><span>3.1. </span>列好相性(Column Affinity)の決定</h2>

<p><a href="stricttables.html">STRICT</a>
として宣言されていないテーブルの場合、列の好相性(こうあいしょう;affinity)は、 以下の規則に従って、 列の宣言された型によって決定されます。</p>

<ol>
  <li>宣言された型に文字列 "INT" が含まれている場合、 INTEGER 好相性(affinity)が割り当てられます。

  </li><li>列の宣言された型に文字列 "CHAR" または  "CLOB" または  "TEXT" が含まれている場合、 その列には TEXT 好相性があります。
VARCHAR 型には文字列 "CHAR" が含まれているため、 TEXT 好相性が割り当てられていることに注意してください(訳注:
CLOB;キャラクター・ラージ・オブジェクト。 OracleやIBM DB2とかにある型)。

  </li><li>列の宣言された型に文字列 "BLOB" が含まれている場合、 または型が指定されていない場合、 列には BLOB 好相性があります。

  </li><li>列の宣言された型に文字列 "REAL" または "FLOA" または "DOUB" のいずれかが含まれている場合、 その列には REAL 好相性
があります。

  </li><li>それ以外の場合は、 NUMERIC 好相性です。
</li></ol>

<p>列の好相性を決定するルールの順序は重要であるということに注意してください。 宣言された型が "CHARINT" である列は、ルール 1 と 2
の両方にマッチングしますが、 最初のルールの方が優先されるため、 列の好相性は INTEGER になります。</p>

<h3 id="affinity_name_examples"><span>3.1.1. </span>好相性名の例</h3>

<p>以下の表は、 より伝統的なSQLの実装でよく使われるデータ型名が、 上記の5つの規則によってどれだけ好相性に変換されるかを示したものです。 注意:
型名に続く括弧内の数値引数 (例: "VARCHAR(255)") は SQLite によって無視されることに注意してください - SQLite は、
(グローバルの <a href="limits.html#max_length">SQLITE_MAX_LENGTH</a>
制限を除き、)文字列の長さ、BLOBの長さ、数値の長さに長さ制限を課しません。</p>

<blockquote> 
<table border="1" cellpadding="5">
<tr><th>CREATE TABLE<br>ステートメントまたは<br>
        CAST 式からの型名の例
    </th><th>結果の好相性
    </th><th>好相性の決定に使われた規則番号

</th></tr><tr><td align="center" valign="top">
  INT<br>
  INTEGER<br>
  TINYINT<br>
  SMALLINT<br>
  MEDIUMINT<br>
  BIGINT<br>
  UNSIGNED BIG INT<br>
  INT2<br>
  INT8
</td><td align="center">INTEGER
</td><td align="center">1

</td></tr><tr><td align="center" valign="top">
  CHARACTER(20)<br>
  VARCHAR(255)<br>
  VARYING CHARACTER(255)<br>
  NCHAR(55)<br>
  NATIVE CHARACTER(70)<br>
  NVARCHAR(100)<br>
  TEXT<br>
  CLOB
</td><td align="center">TEXT
</td><td align="center">2

</td></tr><tr><td align="center" valign="top">
  BLOB<br>
  <i>データ型指定無し</i>
</td><td align="center">BLOB
</td><td align="center">3

</td></tr><tr><td align="center" valign="top">
  REAL<br>
  DOUBLE<br>
  DOUBLE PRECISION<br>
  FLOAT
</td><td align="center">REAL
</td><td align="center">4

</td></tr><tr><td align="center" valign="top">
  NUMERIC<br>
  DECIMAL(10,5)<br>
  BOOLEAN<br>
  DATE<br>
  DATETIME
</td><td align="center">NUMERIC
</td><td align="center">5
</td></tr></table>
</blockquote>

<p>注意: "FLOATING POINT" と宣言された型は、 "POINT" の末尾に "INT" があるため、 REAL 好相性ではなく、
INTEGER 好相性 を与えることに注意してください。 そして "STRING" と宣言された型は、 TEXT ではなく NUMERIC
好相性があります。 <a name="expraff"></a>

</p><h2 id="affinity_of_expressions"><span>3.2. </span>式の好相性</h2>

<p>すべてのテーブル列には型の好相性(BLOB、TEXT、INTEGER、REAL、NUMERIC のいずれか) がありますが、
式には必ずしも好相性があるとは限りません。

</p><p>式の好相性は、以下のルールによって決定されます:

<ul>
  <li>IN または NOT IN 演算子の右側のオペランドは、 オペランドがリストの場合は好相性(affinity)を持たず、 オペランドが SELECT
の場合は結果セット式の好相性と同じ好相性を持ちます。

  </li><li>式が(<a href="lang_createview.html">VIEW</a>
またはサブクエリではない、)実際のテーブルの列への単純な参照である場合、 式はテーブルの列と同じ好相性を持ちます。
  <ul>
  <li>列名を囲む丸括弧(parentheses)は無視されます。 したがって、 X と Y.Z が列名の場合、 (X) と (Y.Z) も列名と見なされ、
対応する列の好相性があります。
  </li><li>
  no-op の "+" 単項演算子を含め、 列名に適用されるすべての演算子は、 列名を常に好相性のない式に変換します。  したがって、 X と Y.Z
が列名であっても、 式 +X と +Y.Z は列名ではなく、 好相性はありません。
  </li></ul>

  </li><li><p>"CAST(<i>expr</i> AS <i>type</i>)" という形式の式には、 宣言された型 "<i>type</i>"
を持つ列と同じ好相性があります。

  </p></li><li><p>COLLATE 演算子は、 左側のオペランドと同じ好相性を持ちます。

  </p></li><li><p>それ以外の場合、 式には好相性がありません。
</li></ul>

<a name="affview"></a>

<h2 id="column_affinity_for_views_and_subqueries"><span>3.3. </span>View とサブクエリの 列好相性</h2>

<p>The "columns" of a <a href="lang_createview.html">VIEW</a> or FROM-clause
subquery are really the expressions in the result set of the <a
href="lang_select.html">SELECT</a> statement that implements the VIEW or
subquery.  Thus, the affinity for columns of a VIEW or subquery are
determined by the expression affinity rules above.  Consider an example:

</p><blockquote><pre>
CREATE TABLE t1(a INT, b TEXT, c REAL);
CREATE VIEW v1(x,y,z) AS SELECT b, a+c, 42 FROM t1 WHERE b!=11;
</pre></blockquote>

<p>The affinity of the v1.x column will be the same as the affinity of t1.b
(TEXT), since v1.x maps directly into t1.b.  But columns v1.y and v1.z both
have no affinity, since those columns map into expression a+c and 42, and
expressions always have no affinity.  <a name="affcompoundview"></a>

</p><h3 id="column_affinity_for_compound_views"><span>3.3.1. </span>複合Viewの列好相性</h3>

<p>When the <a href="lang_select.html">SELECT</a> statement that implements a
<a href="lang_createview.html">VIEW</a> or FROM-clause subquery is a <a
href="lang_select.html#compound">compound SELECT</a> then the affinity of
each column of the VIEW or subquery will be the affinity of the
corresponding result column for one of the individual SELECT statements that
make up the compound.  However, it is indeterminate which of the SELECT
statements will be used to determine affinity.  Different constituent SELECT
statements might be used to determine affinity at different times during
query evaluation.  The choice might vary across different versions of
SQLite.  The choice might change between one query and the next in the same
version of SQLite.  The choice might be different at different times within
the same query.  Hence, you can never be sure what affinity will be used for
columns of a compound SELECT that have different affinities in the
constituent subqueries.

</p><p>Best practice is to avoid mixing affinities in a compound SELECT if you care
about the datatype of the result.  Mixing affinities in a compound SELECT
can lead to surprising and unintuitive results.  See, for example, <a
href="https://sqlite.org/forum/forumpost/02d7be94d7">forum post
02d7be94d7</a>.

</p><h2 id="column_affinity_behavior_example"><span>3.4. </span>列好相性の振る舞いの例</h2>

<p>The following SQL demonstrates how SQLite uses column affinity to do type
conversions when values are inserted into a table.</p>

<blockquote>
<pre>
CREATE TABLE t1(
    t  TEXT,     -- TEXT好相性。規則2による
    nu NUMERIC,  -- NUMERIC好相性。規則5による
    i  INTEGER,  -- INTEGER好相性。規則1による
    r  REAL,     -- REAL好相性。規則4による
    no BLOB      -- 好相性なし。規則3による
);

-- それぞれ TEXT, INTEGER, INTEGER, REAL, TEXT として格納される
INSERT INTO t1 VALUES('500.0', '500.0', '500.0', '500.0', '500.0');
SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;
text|integer|integer|real|text

-- それぞれ TEXT, INTEGER, INTEGER, REAL, REAL として格納される
DELETE FROM t1;
INSERT INTO t1 VALUES(500.0, 500.0, 500.0, 500.0, 500.0);
SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;
text|integer|integer|real|real

-- それぞれ TEXT, INTEGER, INTEGER, REAL, INTEGER として格納される
DELETE FROM t1;
INSERT INTO t1 VALUES(500, 500, 500, 500, 500);
SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;
text|integer|integer|real|integer

-- BLOB は、列の好相性に関係なく、常に BLOB として格納されます
DELETE FROM t1;
INSERT INTO t1 VALUES(x'0500', x'0500', x'0500', x'0500', x'0500');
SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;
blob|blob|blob|blob|blob

-- NULL も好相性の影響を受けません
DELETE FROM t1;
INSERT INTO t1 VALUES(NULL,NULL,NULL,NULL,NULL);
SELECT typeof(t), typeof(nu), typeof(i), typeof(r), typeof(no) FROM t1;
null|null|null|null|null
</pre>
</blockquote>

<a name="comparisons"></a>

<h1 id="comparison_expressions"><span>4. </span>比較式</h1>

<p>SQLite バージョン 3 には、SQL 比較演算子の通常のセットがあります。 "=", "==", "&lt;", "&lt;=", "&gt;",
"&gt;=", "!=", "", "IN", "NOT IN", "BETWEEN", "IS", "IS NOT" です。 (訳注:
念の為いうと、"=&lt;" とか  "=&gt;" とか無い) <a name="sortorder"></a>

</p><h2 id="sort_order"><span>4.1. </span>並べ替え順</h2>

<p>The results of a comparison depend on the storage classes of the operands,
according to the following rules:</p>
<ul>
  <li>A value with storage class NULL is considered less than any other value
(including another value with storage class NULL).

  </li><li>An INTEGER or REAL value is less than any TEXT or BLOB value.  When an
INTEGER or REAL is compared to another INTEGER or REAL, a numerical
comparison is performed.

  </li><li>A TEXT value is less than a BLOB value.  When two TEXT values are compared
an appropriate collating sequence is used to determine the result.  

  </li><li>When two BLOB values are compared, the result is determined using memcmp().
</li></ul>

<a name="compaff"></a>

<h2 id="type_conversions_prior_to_comparison"><span>4.2. </span>比較前の型変換</h2>

<p>SQLite may attempt to convert values between the storage classes INTEGER,
REAL, and/or TEXT before performing a comparison.  Whether or not any
conversions are attempted before the comparison takes place depends on the
type affinity of the operands.

</p><p>To "apply affinity" means to convert an operand to a particular storage
class if and only if the conversion does not lose essential information.
Numeric values can always be converted into TEXT.  TEXT values can be
converted into numeric values if the text content is a well-formed integer
or real literal, but not a hexadecimal integer literal.  BLOB values are
converted into TEXT values by simply interpreting the binary BLOB content as
a text string in the current database encoding.

</p><p>Affinity is applied to operands of a comparison operator prior to the
comparison according to the following rules in the order shown:</p>

<ul>
<li>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand
has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other
operand.

</li><li>If one operand has TEXT affinity and the other has no affinity, then TEXT
affinity is applied to the other operand.

</li><li>Otherwise, no affinity is applied and both operands are compared as is.
</li></ul>

<p>The expression "a BETWEEN b AND c" is treated as two separate binary
comparisons "a &gt;= b AND a &lt;= c", even if that means different
affinities are applied to 'a' in each of the comparisons.  Datatype
conversions in comparisons of the form "x IN (SELECT y ...)" are handled as
if the comparison were really "x=y".  The expression "a IN (x, y, z, ...)"
is equivalent to "a = +x OR a = +y OR a = +z OR ...".  In other words, the
values to the right of the IN operator (the "x", "y", and "z" values in this
example) are considered to have no affinity, even if they happen to be
column values or CAST expressions.  
</p>

<h2 id="comparison_example"><span>4.3. </span>比較の例</h2>

<blockquote>
<pre>
CREATE TABLE t1(
    a TEXT,      -- TEXT好相性
    b NUMERIC,   -- NUMERIC好相性
    c BLOB,      -- 好相性なし
    d            -- 好相性なし
);

-- 値は、それぞれ TEXT、INTEGER、TEXT、INTEGER として格納されるでしょう
INSERT INTO t1 VALUES('500', '500', '500', 500);
SELECT typeof(a), typeof(b), typeof(c), typeof(d) FROM t1;
text|integer|text|integer

-- 列 "a" にはTEXT好相性があるため、 
-- 比較の右側の数値は、
-- 比較が行われる前にTEXTに変換されます。
SELECT a &lt; 40,   a &lt; 60,   a &lt; 600 FROM t1;
0|1|1

-- TEXT好相性が右側のオペランドに適用されますが、
-- それらは既に TEXT であるため、 何もしません。 変換は発生しません。
SELECT a &lt; '40', a &lt; '60', a &lt; '600' FROM t1;
0|1|1

-- 列 "b" には NUMERIC 好相性があるため、 右側のオペランドに
-- NUMERIC 好相性が適用されます。 オペランドはすでに数値(NUMERIC)であるため、
-- 好相性適用操作は行われず、 変換は発生しません。
-- よって、 すべての値が数値的に比較されます。
SELECT b &lt; 40,   b &lt; 60,   b &lt; 600 FROM t1;
0|0|1

-- 右側のオペランドにNUMERIC好相性が適用され、
-- テキストから整数に変換されます。 それに続いて数値比較が行われます。
SELECT b &lt; '40', b &lt; '60', b &lt; '600' FROM t1;
0|0|1

-- 好相性変換は発生しません。
-- 右側の値はすべて格納クラス INTEGER を持ち、
-- 常に左側の TEXT 値よりも小さいです。
SELECT c &lt; 40,   c &lt; 60,   c &lt; 600 FROM t1;
0|0|0

-- 好相性変換は発生しません。 値は TEXT として比較されます。
SELECT c &lt; '40', c &lt; '60', c &lt; '600' FROM t1;
0|1|1

-- 好相性変換は発生しません。
-- 右側の値はすべて、
-- 左側の INTEGER 値と数値的に比較する、 格納クラス INTEGER を持ちます。
SELECT d &lt; 40,   d &lt; 60,   d &lt; 600 FROM t1;
0|0|1

-- 好相性変換は発生しません。
-- 左側の INTEGER 値は、 常に右側の TEXT 値より小さくなります。
SELECT d &lt; '40', d &lt; '60', d &lt; '600' FROM t1;
1|1|1
</pre>
</blockquote>

<p>All of the results in the example are the same if the comparisons are
commuted - if expressions of the form "a&lt;40" are rewritten as "40&gt;a".

</p><h1 id="operators"><span>5. </span>演算子</h1>

<p>Mathematical operators (+, -, *, /, %, &lt;&lt;, &gt;&gt;, &amp;, and |)
interpret both operands as if they were numbers.  STRING or BLOB operands
automatically convert into REAL or INTEGER values.  If the STRING or BLOB
looks like a real number (if it has a decimal point or an exponent) or if
the value is outside the range that can be represented as a 64-bit signed
integer, then it converts to REAL.  Otherwise the operand converts to
INTEGER.  The implied type conversion of mathematical operands is slightly
different from <a href="lang_expr.html#castexpr">CAST to NUMERIC</a> in that
string and BLOB values that look like real numbers but have no fractional
part are kept as REAL instead of being converted into INTEGER as they would
be for <a href="lang_expr.html#castexpr">CAST to NUMERIC</a>.  The
conversion from STRING or BLOB into REAL or INTEGER is performed even if it
is lossy and irreversible.  Some mathematical operators (%, &lt;&lt;,
&gt;&gt;, &amp;, and |) expect INTEGER operands.  For those operators, REAL
operands are converted into INTEGER in the same way as a <a
href="lang_expr.html#castexpr">CAST to INTEGER</a>.  The &lt;&lt;, &gt;&gt;,
&amp;, and | operators always return an INTEGER (or NULL)  result, but the %
operator returns either INTEGER or REAL (or NULL)  depending on the type of
its operands.  A NULL operand on a mathematical operator yields a NULL
result.  An operand on a mathematical operator that does not look in any way
numeric and is not NULL is converted to 0 or 0.0.  Division by zero gives a
result of NULL.
</p>

<h1 id="sorting_grouping_and_compound_selects"><span>6. </span>並べ替え(sorting)と集計(grouping)と複合(compound)SELECT</h1>

<p>When query results are sorted by an ORDER BY clause, values with storage
class NULL come first, followed by INTEGER and REAL values interspersed in
numeric order, followed by TEXT values in collating sequence order, and
finally BLOB values in memcmp() order.  No storage class conversions occur
before the sort.</p>

<p>When grouping values with the GROUP BY clause values with different storage
classes are considered distinct, except for INTEGER and REAL values which
are considered equal if they are numerically equal. No affinities are
applied to any values as the result of a GROUP by clause.</p>

<p>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit
comparisons between values.  No affinity is applied to comparison operands
for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT -
the values are compared as is.</p>

<a name="collation"></a>

<h1 id="collating_sequences"><span>7. </span>照合シーケンス(Collating Sequences)</h1>

<p>SQLite が 2 つの文字列を比較するとき、 照合シーケンス(collating sequence)または照合関数collating
function (同じことを表す 2 つの用語) を使用して、 どちらの文字列が大きいか、 または 2 つの文字列が等しいかどうかを判断します。
SQLite には、 BINARY と NOCASE と RTRIM の 3 つの組み込み照合関数(collating functions)があります。</p>

<ul>
<li><b>BINARY</b> - Compares string data using memcmp(), regardless of text
encoding.</li>
<li><b>NOCASE</b> - Similar to binary, except that it uses <a
href="c3ref/stricmp.html">sqlite3_strnicmp()</a> for the comparison.  Hence
the 26 upper case characters of ASCII are folded to their lower case
equivalents before the comparison is performed.  Note that only ASCII
characters are case folded.  SQLite does not attempt to do full UTF case
folding due to the size of the tables required.  Also note that any U+0000
characters in the string are considered string terminators for comparison
purposes.

</li><li><b>RTRIM</b> - 末尾のスペース文字が無視されることを除いて、 BINARYと同一です。 (訳注: Right TRIM → RTRIM)</li>
</ul>

<p>An application can register additional collating functions using the <a
href="c3ref/create_collation.html">sqlite3_create_collation()</a> interface.</p>

<p>Collating functions only matter when comparing string values.  Numeric
values are always compared numerically, and BLOBs are always compared
byte-by-byte using memcmp().</p>

<h2 id="assigning_collating_sequences_from_sql"><span>7.1. </span>SQL から照合シーケンスを割り当てる</h2>

<p>
Every column of every table has an associated collating function.  If no
collating function is explicitly defined, then the collating function
defaults to BINARY.  The COLLATE clause of the <a
href="lang_createtable.html#tablecoldef">column definition</a> is used to
define alternative collating functions for a column.
</p>

<a name="colrules"></a>


<p>
The rules for determining which collating function to use for a binary
comparison operator (=, &lt;, &gt;, &lt;=, &gt;=, !=, IS, and IS NOT) are as
follows:

<ol>
<li>If either operand has an explicit collating function assignment using the
postfix <a href="lang_expr.html#collateop">COLLATE operator</a>, then the
explicit collating function is used for comparison, with precedence to the
collating function of the left operand.</li>

<li>If either operand is a column, then the collating function of that column is
used with precedence to the left operand.  For the purposes of the previous
sentence, a column name preceded by one or more unary "+" operators and/or
CAST operators is still considered a column name.
</li>

<li>Otherwise, the BINARY collating function is used for comparison.
</li>
</ol>

<p>
An operand of a comparison is considered to have an explicit collating
function assignment (rule 1 above)  if any subexpression of the operand uses
the postfix <a href="lang_expr.html#collateop">COLLATE operator</a>.  Thus,
if a <a href="lang_expr.html#collateop">COLLATE operator</a> is used
anywhere in a comparison expression, the collating function defined by that
operator is used for string comparison regardless of what table columns
might be a part of that expression.  If two or more <a
href="lang_expr.html#collateop">COLLATE operator</a> subexpressions appear
anywhere in a comparison, the left most explicit collating function is used
regardless of how deeply the COLLATE operators are nested in the expression
and regardless of how the expression is parenthesized.
</p>

<p>
The expression "x BETWEEN y and z" is logically equivalent to two
comparisons "x &gt;= y AND x &lt;= z" and works with respect to collating
functions as if it were two separate comparisons.  The expression "x IN
(SELECT y ...)" is handled in the same way as the expression "x = y" for the
purposes of determining the collating sequence.  The collating sequence used
for expressions of the form "x IN (y, z, ...)" is the collating sequence of
x.  If an explicit collating sequence is required on an IN operator it
should be applied to the left operand, like this: "x COLLATE nocase IN (y,z,
...)".
</p>  

<p>
Terms of the ORDER BY clause that is part of a <a
href="lang_select.html">SELECT</a> statement may be assigned a collating
sequence using the <a href="lang_expr.html#collateop">COLLATE operator</a>,
in which case the specified collating function is used for sorting.
Otherwise, if the expression sorted by an ORDER BY clause is a column, then
the collating sequence of the column is used to determine sort order. If the
expression is not a column and has no COLLATE clause, then the BINARY
collating sequence is used.
</p>  

<h2 id="collation_sequence_examples"><span>7.2. </span>照合シーケンス(Collation Sequence)の例</h2>
<p>
The examples below identify the collating sequences that would be used to
determine the results of text comparisons that may be performed by various
SQL statements. Note that a text comparison may not be required, and no
collating sequence used, in the case of numeric, blob or NULL values.
</p>
<blockquote>
<pre>
CREATE TABLE t1(
    x INTEGER PRIMARY KEY,
    a,                 /* 照合シーケンス BINARY */
    b COLLATE BINARY,  /* 照合シーケンス BINARY */
    c COLLATE RTRIM,   /* 照合シーケンス RTRIM  */
    d COLLATE NOCASE   /* 照合シーケンス NOCASE */
);
                   /* x   a     b     c       d */
INSERT INTO t1 VALUES(1,'abc','abc', 'abc  ','abc');
INSERT INTO t1 VALUES(2,'abc','abc', 'abc',  'ABC');
INSERT INTO t1 VALUES(3,'abc','abc', 'abc ', 'Abc');
INSERT INTO t1 VALUES(4,'abc','abc ','ABC',  'abc');

/* 訳注:
1行目: c の後ろに空白2つ
2行目: d 大文字ABC
3行目: c 後ろ空白1つ、 d 大文字小文字混在
4行目: b 後ろ空白1つ、 c 大文字ABC
*/

/* テキスト比較 a = b は、 BINARY 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE a = b ORDER BY x;
--result 1 2 3

/* テキスト比較 a = b は、 RTRIM 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE a = b COLLATE RTRIM ORDER BY x;
--result 1 2 3 4

/* テキスト比較 d = a は、NOCASE 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE d = a ORDER BY x;
--result 1 2 3 4

/* テキスト比較 a = d は、 BINARY 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE a = d ORDER BY x;
--result 1 4

/* テキスト比較 'abc' = c は、RTRIM 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE 'abc' = c ORDER BY x;
--result 1 2 3

/* テキスト比較 c = 'abc' は、 RTRIM 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 WHERE c = 'abc' ORDER BY x;
--result 1 2 3

/* グループ化は、 NOCASE 照合シーケンスを使用して実行されます。
** (値 'abc' と 'ABC' と 'Abc' は同一グループに配置されます) */
SELECT count(*) FROM t1 GROUP BY d ORDER BY 1;
--result 4

/* グループ化は、 BINARY 照合シーケンスを使用して実行されます。
** 'abc' と 'ABC' と 'Abc' は異なるグループを形成します */
SELECT count(*) FROM t1 GROUP BY (d || '') ORDER BY 1;
--result 1 1 2

/* ソートまたは列 c は、 RTRIM 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 ORDER BY c, x;
--result 4 1 2 3

/* (c||'') のソートは、 BINARY 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 ORDER BY (c||''), x;
--result 4 2 3 1

/* 列 c のソートは、 NOCASE 照合シーケンスを使用して実行されます。 */
SELECT x FROM t1 ORDER BY c COLLATE NOCASE, x;
--result 2 4 3 1
</pre>
</blockquote>


