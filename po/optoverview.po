# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-03-16 16:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Content of: <html><body><div><div><div>
#: sedout/optoverview.html:6 sedout/optoverview.html:121
msgid "The SQLite Query Optimizer Overview"
msgstr ""

#. type: Content of: <html><body><div><a>
#: sedout/optoverview.html:11
msgid "<a href=\"index.html\">"
msgstr ""

#. type: Attribute 'alt' of: <html><body><div><a><img>
#: sedout/optoverview.html:12
msgid "SQLite"
msgstr ""

#. type: Content of: <html><body><div><div>
#: sedout/optoverview.html:16
msgid "Small. Fast. Reliable."
msgstr ""

#. type: Content of: <html><body><div><div><br>
#: sedout/optoverview.html:16
msgid "Choose any three."
msgstr ""

#. type: Content of: <html><body><div><div><ul><li>
#: sedout/optoverview.html:20
msgid "<a href=\"index.html\">Home</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li>
#: sedout/optoverview.html:21
msgid ""
"<a href=\"javascript:void(0)\" onclick='toggle_div(\"submenu\")'>Menu</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li>
#: sedout/optoverview.html:22 sedout/optoverview.html:34
msgid "<a href='about.html'>About</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li>
#: sedout/optoverview.html:23
msgid "<a href=\"docs.html\">Documentation</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li>
#: sedout/optoverview.html:24
msgid "<a href=\"download.html\">Download</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li><li>
#: sedout/optoverview.html:25
msgid "<a href='copyright.html'>License</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li><li><li>
#: sedout/optoverview.html:26
msgid "<a href=\"support.html\">Support</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li><li><li><li>
#: sedout/optoverview.html:27
msgid "<a href=\"prosupport.html\">Purchase</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li><li><li><li><li>
#: sedout/optoverview.html:29
msgid "<a href=\"javascript:void(0)\" onclick='toggle_search()'>Search</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li>
#: sedout/optoverview.html:35
msgid "<a href='docs.html'>Documentation</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li>
#: sedout/optoverview.html:36
msgid "<a href='download.html'>Download</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li>
#: sedout/optoverview.html:37
msgid "<a href='support.html'>Support</a>"
msgstr ""

#. type: Content of: <html><body><div><div><ul><li><li><li><li><li>
#: sedout/optoverview.html:38
msgid "<a href='prosupport.html'>Purchase</a>"
msgstr ""

#. type: Content of: <html><body><div><div><form><select>
#: sedout/optoverview.html:43
msgid "<select name=\"s\" id=\"searchtype\">"
msgstr ""

#. type: Content of: <html><body><div><div><form><select><option>
#: sedout/optoverview.html:44
msgid "Search Documentation"
msgstr ""

#. type: Content of: <html><body><div><div><form><select><option>
#: sedout/optoverview.html:45
msgid "Search Changelog"
msgstr ""

#. type: Content of: <html><body><div><div><form>
#: sedout/optoverview.html:46
msgid ""
"</select> <input type=\"text\" name=\"q\" id=\"searchbox\" value=\"\"/> "
"<input type=\"submit\" value=\"Go\"/>"
msgstr ""

#. type: Content of: <html><body><script>
#: sedout/optoverview.html:53
msgid ""
"function toggle_div(nm) { var w = document.getElementById(nm); if( w.style."
"display==\"block\" ){ w.style.display = \"none\"; }else{ w.style.display = "
"\"block\"; } } function toggle_search() { var w = document."
"getElementById(\"searchmenu\"); if( w.style.display==\"block\" ){ w.style."
"display = \"none\"; } else { w.style.display = \"block\"; "
"setTimeout(function(){ document.getElementById(\"searchbox\").focus()  }, "
"30); } } function div_off(nm){document.getElementById(nm).style."
"display=\"none\";} window.onbeforeunload = function(e)"
"{div_off(\"submenu\");} /* Disable the Search feature if we are not "
"operating from CGI, since */ /* Search is accomplished using CGI and will "
"not work without it. */ if( !location.origin || !location.origin.match || !"
"location.origin.match(/http/) ){ document."
"getElementById(\"search_menubutton\").style.display = \"none\"; } /* Used by "
"the Hide/Show button beside syntax diagrams, to toggle the */ function "
"hideorshow(btn,obj){ var x = document.getElementById(obj); var b = document."
"getElementById(btn); if( x.style.display!='none' ){ x.style.display = "
"'none'; b.innerHTML='show'; }else{ x.style.display = ''; b."
"innerHTML='hide'; } return false; } var antiRobot = 0; function antiRobotGo()"
"{ if( antiRobot!=3 ) return; antiRobot = 7; var j = document."
"getElementById(\"mtimelink\"); if(j && j.hasAttribute(\"data-href\")) j."
"href=j.getAttribute(\"data-href\"); } function antiRobotDefense(){ document."
"body.onmousedown=function(){ antiRobot |= 2; antiRobotGo(); document.body."
"onmousedown=null; } document.body.onmousemove=function(){ antiRobot |= 2; "
"antiRobotGo(); document.body.onmousemove=null; } setTimeout(function()"
"{ antiRobot |= 1; antiRobotGo(); }, 100)  antiRobotGo(); } "
"antiRobotDefense();"
msgstr ""

#. type: Content of: <html><body><div><div><div>
#: sedout/optoverview.html:124
msgid ""
"<a onclick=\"toggle_toc()\"> <span class=\"fancy_toc_mark\" "
"id=\"toc_mk\">&#x25ba;</span> Table Of Contents </a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:128
msgid "<a href=\"#introduction\">1. Introduction</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:129
msgid "<a href=\"#where_clause_analysis\">2. WHERE Clause Analysis</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:130
msgid ""
"<a href=\"#index_term_usage_examples\">2.1. Index Term Usage Examples</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:131
msgid "<a href=\"#the_between_optimization\">3. The BETWEEN Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:132
msgid "<a href=\"#or_optimizations\">4. OR Optimizations</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:133
msgid "<a href=\"#the_like_optimization\">5. The LIKE Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:134
msgid ""
"<a href=\"#the_skip_scan_optimization\">6. The Skip-Scan Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:135
msgid "<a href=\"#joins\">7. Joins</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:136
msgid ""
"<a href=\"#order_of_tables_in_a_join\">7.1. Order of Tables in a Join</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:137
msgid ""
"<a href=\"#manual_control_of_query_plans_using_sqlite_stat_tables\">7.2. "
"Manual Control Of Query Plans Using SQLITE_STAT Tables</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:138
msgid ""
"<a href=\"#manual_control_of_query_plans_using_cross_join\">7.3. Manual "
"Control of Query Plans using CROSS JOIN</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:139
msgid ""
"<a href=\"#choosing_between_multiple_indexes\">8. Choosing Between Multiple "
"Indexes</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:140
msgid ""
"<a href=\"#disqualifying_where_clause_terms_using_unary_\">8.1. "
"Disqualifying WHERE Clause Terms using Unary-\"+\"</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:141
msgid "<a href=\"#range_queries\">8.2. Range Queries</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:142
msgid "<a href=\"#covering_indexes\">9. Covering Indexes</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:143
msgid "<a href=\"#order_by_optimizations\">10. ORDER BY Optimizations</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:144
msgid ""
"<a href=\"#partial_order_by_via_index\">10.1. Partial ORDER BY via Index</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:145
msgid "<a href=\"#subquery_flattening\">11. Subquery Flattening</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:146
msgid "<a href=\"#subquery_co_routines\">12. Subquery Co-routines</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:147
msgid ""
"<a href=\"#using_co_routines_to_defer_work_until_after_the_sorting\">12.1. "
"Using Co-routines to Defer Work until after the Sorting</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:148
msgid "<a href=\"#the_min_max_optimization\">13. The MIN/MAX Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:149
msgid "<a href=\"#automatic_indexes\">14. Automatic Indexes</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:150
msgid "<a href=\"#hash_joins\">14.1. Hash Joins</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:151
msgid ""
"<a href=\"#the_push_down_optimization\">15. The Push-Down Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:152
msgid ""
"<a href=\"#the_left_join_strength_reduction_optimization\">16. The LEFT JOIN "
"Strength Reduction Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:153
msgid ""
"<a href=\"#the_omit_left_join_optimization\">17. The Omit LEFT JOIN "
"Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><div><div><div>
#: sedout/optoverview.html:154
msgid ""
"<a href=\"#the_constant_propagation_optimization\">18. The Constant "
"Propagation Optimization</a>"
msgstr ""

#. type: Content of: <html><body><div><div><script>
#: sedout/optoverview.html:158
msgid ""
"function toggle_toc(){ var sub = document.getElementById(\"toc_sub\")  var "
"mk = document.getElementById(\"toc_mk\")  if( sub.style.display!=\"block\" )"
"{ sub.style.display = \"block\"; mk.innerHTML = \"&#x25bc;\"; } else { sub."
"style.display = \"none\"; mk.innerHTML = \"&#x25ba;\"; } }"
msgstr ""

#. type: Content of: <html><body><div><h1>
#: sedout/optoverview.html:176
msgid "<span>1. </span>Introduction"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:178
msgid ""
"This document provides an overview of how the query planner and optimizer "
"for SQLite works."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:183
msgid ""
"Given a single SQL statement, there might be dozens, hundreds, or even "
"thousands of ways to implement that statement, depending on the complexity "
"of the statement itself and of the underlying database schema.  The task of "
"the query planner is to select the algorithm that minimizes disk I/O and CPU "
"overhead."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:191
msgid ""
"Additional background information is available in the <a href=\"queryplanner."
"html\">indexing tutorial</a> document."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:196
msgid ""
"With release 3.8.0 (2013-08-26), the SQLite query planner was reimplemented "
"as the <a href=\"queryplanner-ng.html\">Next Generation Query Planner</a> or "
"\"NGQP\".  All of the features, techniques, and algorithms described in this "
"document are applicable to both the pre-3.8.0 legacy query planner and to "
"the NGQP.  For further information on how the NGQP differs from the legacy "
"query planner, see the <a href=\"queryplanner-ng.html\">detailed description "
"of the NGQP</a>.  <a name=\"where_clause\"></a>"
msgstr ""

#. type: Content of: <html><body><div><h1>
#: sedout/optoverview.html:209
msgid "<span>2. </span>WHERE Clause Analysis"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:212
msgid ""
"The WHERE clause on a query is broken up into \"terms\" where each term is "
"separated from the others by an AND operator.  If the WHERE clause is "
"composed of constraints separated by the OR operator then the entire clause "
"is considered to be a single \"term\" to which the <a href=\"#or_opt\">OR-"
"clause optimization</a> is applied."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:219
msgid ""
"All terms of the WHERE clause are analyzed to see if they can be satisfied "
"using indexes.  To be usable by an index a term must usually be of one of "
"the following forms:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:224
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>column</i><b> = </b><i>expression</i><b>\n"
"  </b><i>column</i><b> IS </b><i>expression</i><b>\n"
"  </b><i>column</i><b> &gt; </b><i>expression</i><b>\n"
"  </b><i>column</i><b> &gt;= </b><i>expression</i><b>\n"
"  </b><i>column</i><b> &lt; </b><i>expression</i><b>\n"
"  </b><i>column</i><b> &lt;= </b><i>expression</i><b>\n"
"  </b><i>expression</i><b> = </b><i>column</i><b>\n"
"  </b><i>expression</i><b> &gt; </b><i>column</i><b>\n"
"  </b><i>expression</i><b> &gt;= </b><i>column</i><b>\n"
"  </b><i>expression</i><b> &lt; </b><i>column</i><b>\n"
"  </b><i>expression</i><b> &lt;= </b><i>column</i><b>\n"
"  </b><i>column</i><b> IN (</b><i>expression-list</i><b>)\n"
"  </b><i>column</i><b> IN (</b><i>subquery</i><b>)\n"
"  </b><i>column</i><b> IS NULL\n"
"  </b><i>column</i><b> LIKE </b><i>pattern</i><b>\n"
"  </b><i>column</i><b> GLOB </b><i>pattern</i><b>\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:244
msgid "If an index is created using a statement like this:"
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:246
#, no-wrap
msgid "CREATE INDEX idx_ex1 ON ex1(a,b,c,d,e,...,y,z);\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:250
msgid ""
"Then the index might be used if the initial columns of the index (columns a, "
"b, and so forth) appear in WHERE clause terms.  The initial columns of the "
"index must be used with the"
msgstr ""

#. type: Content of: <html><body><div><p><b&gt;=</b>
#: sedout/optoverview.html:253
msgid ""
"or <b>IN</b> or <b>IS</b> operators.  The right-most column that is used can "
"employ inequalities.  For the right-most column of an index that is used, "
"there can be up to two inequalities that must sandwich the allowed values of "
"the column between two extremes."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:260
msgid ""
"It is not necessary for every column of an index to appear in a WHERE clause "
"term in order for that index to be used.  However, there cannot be gaps in "
"the columns of the index that are used.  Thus for the example index above, "
"if there is no WHERE clause term that constrains column c, then terms that "
"constrain columns a and b can be used with the index but not terms that "
"constrain columns d through z.  Similarly, index columns will not normally "
"be used (for indexing purposes)  if they are to the right of a column that "
"is constrained only by inequalities.  (See the <a href=\"optoverview."
"html#skipscan\">skip-scan optimization</a> below for the exception.)"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:272
msgid ""
"In the case of <a href=\"expridx.html\">indexes on expressions</a>, whenever "
"the word \"column\" is used in the foregoing text, one can substitute "
"\"indexed expression\" (meaning a copy of the expression that appears in the "
"<a href=\"lang_createindex.html\">CREATE INDEX</a> statement) and everything "
"will work the same.  <a name=\"idxexamp\"></a>"
msgstr ""

#. type: Content of: <html><body><div><h2>
#: sedout/optoverview.html:280
msgid "<span>2.1. </span>Index Term Usage Examples"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:282 sedout/optoverview.html:292
#: sedout/optoverview.html:302 sedout/optoverview.html:312
#: sedout/optoverview.html:322
msgid "For the index above and WHERE clause like this:"
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:284
#, no-wrap
msgid "... WHERE a=5 AND b IN (1,2,3) AND c IS NULL AND d='hello'\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:287
msgid ""
"The first four columns a, b, c, and d of the index would be usable since "
"those four columns form a prefix of the index and are all bound by equality "
"constraints."
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:294
#, no-wrap
msgid "... WHERE a=5 AND b IN (1,2,3) AND c>12 AND d='hello'\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:297
msgid ""
"Only columns a, b, and c of the index would be usable.  The d column would "
"not be usable because it occurs to the right of c and c is constrained only "
"by inequalities."
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:304
#, no-wrap
msgid "... WHERE a=5 AND b IN (1,2,3) AND d='hello'\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:307
msgid ""
"Only columns a and b of the index would be usable.  The d column would not "
"be usable because column c is not constrained and there can be no gaps in "
"the set of columns that usable by the index."
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:314
#, no-wrap
msgid "... WHERE b IN (1,2,3) AND c NOT NULL AND d='hello'\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:317
msgid ""
"The index is not usable at all because the left-most column of the index "
"(column \"a\") is not constrained.  Assuming there are no other indexes, the "
"query above would result in a full table scan."
msgstr ""

#. type: Content of: <html><body><div><div><pre>
#: sedout/optoverview.html:324
#, no-wrap
msgid "... WHERE a=5 OR b IN (1,2,3) OR c NOT NULL OR d='hello'\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:327
msgid ""
"The index is not usable because the WHERE clause terms are connected by OR "
"instead of AND. This query would result in a full table scan.  However, if "
"three additional indexes where added that contained columns b, c, and d as "
"their left-most columns, then the <a href=\"#or_opt\">OR-clause "
"optimization</a> might apply.  <a name=\"between_opt\"></a>"
msgstr ""

#. type: Content of: <html><body><div><h1>
#: sedout/optoverview.html:336
msgid "<span>3. </span>The BETWEEN Optimization"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:339
msgid "If a term of the WHERE clause is of the following form:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:341
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>expr1</i><b> BETWEEN </b><i>expr2</i><b> AND </b><i>expr3</i><b>\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:345
msgid "Then two \"virtual\" terms are added as follows:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:347
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>expr1</i><b> &gt;= </b><i>expr2</i><b> AND </b><i>expr1</i><b> &lt;= </b><i>expr3</i><b>\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:351
msgid ""
"Virtual terms are used for analysis only and do not cause any byte-code to "
"be generated.  If both virtual terms end up being used as constraints on an "
"index, then the original BETWEEN term is omitted and the corresponding test "
"is not performed on input rows.  Thus if the BETWEEN term ends up being used "
"as an index constraint no tests are ever performed on that term.  On the "
"other hand, the virtual terms themselves never causes tests to be performed "
"on input rows.  Thus if the BETWEEN term is not used as an index constraint "
"and instead must be used to test input rows, the <i>expr1</i> expression is "
"only evaluated once.  <a name=\"or_opt\"></a>"
msgstr ""

#. type: Content of: <html><body><div><h1>
#: sedout/optoverview.html:367
msgid "<span>4. </span>OR Optimizations"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:370
msgid ""
"WHERE clause constraints that are connected by OR instead of AND can be "
"handled in two different ways.  If a term consists of multiple subterms "
"containing a common column name and separated by OR, like this:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:375
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>column</i><b> = </b><i>expr1</i><b> OR </b><i>column</i><b> = </b><i>expr2</i><b> OR </b><i>column</i><b> = </b><i>expr3</i><b> OR ...\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:379
msgid "Then that term is rewritten as follows:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:381
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>column</i><b> IN (</b><i>expr1</i><b>,</b><i>expr2</i><b>,</b><i>expr3</i><b>,...)\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:385
msgid ""
"The rewritten term then might go on to constrain an index using the normal "
"rules for <b>IN</b> operators.  Note that <i>column</i> must be the same "
"column in every OR-connected subterm, although the column can occur on "
"either the left or the right side of the"
msgstr ""

#. type: Content of: <html><body><div><p><b&gt;=</b>
#: sedout/optoverview.html:389
msgid "operator."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:392
msgid ""
"If and only if the previously described conversion of OR to an IN operator "
"does not work, the second OR-clause optimization is attempted.  Suppose the "
"OR clause consists of multiple subterms as follows:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:396
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>expr1</i><b> OR </b><i>expr2</i><b> OR </b><i>expr3</i><b>\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:400
msgid ""
"Individual subterms might be a single comparison expression like <b>a=5</b> "
"or <b>x&gt;y</b> or they can be LIKE or BETWEEN expressions, or a subterm "
"can be a parenthesized list of AND-connected sub-subterms.  Each subterm is "
"analyzed as if it were itself the entire WHERE clause in order to see if the "
"subterm is indexable by itself.  If <u>every</u> subterm of an OR clause is "
"separately indexable then the OR clause might be coded such that a separate "
"index is used to evaluate each term of the OR clause.  One way to think "
"about how SQLite uses separate indexes for each OR clause term is to imagine "
"that the WHERE clause where rewritten as follows:"
msgstr ""

#. type: Content of: <html><body><div><p><blockquote><pre>
#: sedout/optoverview.html:412
#, no-wrap
msgid ""
"<b>\n"
"  rowid IN (SELECT rowid FROM </b><i>table</i><b> WHERE </b><i>expr1</i><b>\n"
"            UNION SELECT rowid FROM </b><i>table</i><b> WHERE </b><i>expr2</i><b>\n"
"            UNION SELECT rowid FROM </b><i>table</i><b> WHERE </b><i>expr3</i><b>)\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:418
msgid ""
"The rewritten expression above is conceptual; WHERE clauses containing OR "
"are not really rewritten this way.  The actual implementation of the OR "
"clause uses a mechanism that is more efficient and that works even for <a "
"href=\"withoutrowid.html\">WITHOUT ROWID</a> tables or tables in which the "
"\"rowid\" is inaccessible.  Nevertheless, the essence of the implementation "
"is captured by the statement above: Separate indexes are used to find "
"candidate result rows from each OR clause term and the final result is the "
"union of those rows."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:429
msgid ""
"Note that in most cases, SQLite will only use a single index for each table "
"in the FROM clause of a query.  The second OR-clause optimization described "
"here is the exception to that rule.  With an OR-clause, a different index "
"might be used for each subterm in the OR-clause."
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:435
msgid ""
"For any given query, the fact that the OR-clause optimization described here "
"can be used does not guarantee that it will be used.  SQLite uses a cost-"
"based query planner that estimates the CPU and disk I/O costs of various "
"competing query plans and chooses the plan that it thinks will be the "
"fastest.  If there are many OR terms in the WHERE clause or if some of the "
"indexes on individual OR-clause subterms are not very selective, then SQLite "
"might decide that it is faster to use a different query algorithm, or even a "
"full-table scan.  Application developers can use the <a href=\"lang_explain."
"html\">EXPLAIN QUERY PLAN</a> prefix on a statement to get a high-level "
"overview of the chosen query strategy.  <a name=\"like_opt\"></a>"
msgstr ""

#. type: Content of: <html><body><div><h1>
#: sedout/optoverview.html:449
msgid "<span>5. </span>The LIKE Optimization"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:452
msgid ""
"A WHERE-clause term that uses the <a href=\"lang_expr.html#like\">LIKE</a> "
"or <a href=\"lang_expr.html#glob\">GLOB</a> operator can sometimes be used "
"with an index to do a range search, almost as if the LIKE or GLOB were an "
"alternative to a <a href=\"lang_expr.html#between\">BETWEEN</a> operator.  "
"There are many conditions on this optimization:"
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:460
msgid ""
"The right-hand side of the LIKE or GLOB must be either a string literal or a "
"<a href=\"lang_expr.html#varparam\">parameter</a> bound to a string literal "
"that does not begin with a wildcard character."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:463
msgid ""
"It must not be possible to make the LIKE or GLOB operator true by having a "
"numeric value (instead of a string or blob) on the left-hand side. This "
"means that either:"
msgstr ""

#. type: Content of: <html><body><div><p><ol><li><ol><li>
#: sedout/optoverview.html:467
msgid ""
"the left-hand side of the LIKE or GLOB operator is the name of an indexed "
"column with <a href=\"datatype3.html#affinity\">TEXT affinity</a>, or"
msgstr ""

#. type: Content of: <html><body><div><p><ol><li><ol><li>
#: sedout/optoverview.html:469
msgid ""
"the right-hand side pattern argument does not begin with a minus sign (\"-"
"\") or a digit."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:472
msgid ""
"This constraint arises from the fact that numbers do not sort in "
"lexicographical order.  For example: 9&lt;10 but '9'&gt;'10'."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:474
msgid ""
"The built-in functions used to implement LIKE and GLOB must not have been "
"overloaded using the <a href=\"c3ref/create_function."
"html\">sqlite3_create_function()</a> API."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:476
msgid ""
"For the GLOB operator, the column must be indexed using the built-in BINARY "
"collating sequence."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:478
msgid ""
"For the LIKE operator, if <a href=\"pragma."
"html#pragma_case_sensitive_like\">case_sensitive_like</a> mode is enabled "
"then the column must indexed using BINARY collating sequence, or if <a "
"href=\"pragma.html#pragma_case_sensitive_like\">case_sensitive_like</a> mode "
"is disabled then the column must indexed using built-in NOCASE collating "
"sequence."
msgstr ""

#. type: Content of: <html><body><div><p><ol><li>
#: sedout/optoverview.html:482
msgid ""
"If the ESCAPE option is used, the ESCAPE character must be ASCII, or a "
"single-byte character in UTF-8."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:487
msgid ""
"The LIKE operator has two modes that can be set by a <a href=\"pragma."
"html#pragma_case_sensitive_like\">pragma</a>.  The default mode is for LIKE "
"comparisons to be insensitive to differences of case for latin1 characters.  "
"Thus, by default, the following expression is true:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:493
#, no-wrap
msgid "'a' LIKE 'A'\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:496
msgid "If the case_sensitive_like pragma is enabled as follows:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:498
#, no-wrap
msgid "PRAGMA case_sensitive_like=ON;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:501
msgid ""
"Then the LIKE operator pays attention to case and the example above would "
"evaluate to false.  Note that case insensitivity only applies to latin1 "
"characters - basically the upper and lower case letters of English in the "
"lower 127 byte codes of ASCII.  International character sets are case "
"sensitive in SQLite unless an application-defined <a href=\"datatype3."
"html#collation\">collating sequence</a> and <a href=\"lang_corefunc."
"html#like\">like() SQL function</a> are provided that take non-ASCII "
"characters into account.  If an application-defined collating sequence and/"
"or like() SQL function are provided, the LIKE optimization described here "
"will never be taken."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:513
msgid ""
"The LIKE operator is case insensitive by default because this is what the "
"SQL standard requires.  You can change the default behavior at compile time "
"by using the <a href=\"compile."
"html#case_sensitive_like\">SQLITE_CASE_SENSITIVE_LIKE</a> command-line "
"option to the compiler."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:519
msgid ""
"The LIKE optimization might occur if the column named on the left of the "
"operator is indexed using the built-in BINARY collating sequence and "
"case_sensitive_like is turned on.  Or the optimization might occur if the "
"column is indexed using the built-in NOCASE collating sequence and the "
"case_sensitive_like mode is off.  These are the only two combinations under "
"which LIKE operators will be optimized."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:527
msgid ""
"The GLOB operator is always case sensitive.  The column on the left side of "
"the GLOB operator must always use the built-in BINARY collating sequence or "
"no attempt will be made to optimize that operator with indexes."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:532
msgid ""
"The LIKE optimization will only be attempted if the right-hand side of the "
"GLOB or LIKE operator is either literal string or a <a href=\"lang_expr."
"html#varparam\">parameter</a> that has been <a href=\"c3ref/bind_blob."
"html\">bound</a> to a string literal.  The string literal must not begin "
"with a wildcard; if the right-hand side begins with a wildcard character "
"then this optimization is not attempted.  If the right-hand side is a <a "
"href=\"lang_expr.html#varparam\">parameter</a> that is bound to a string, "
"then this optimization is only attempted if the <a href=\"c3ref/stmt."
"html\">prepared statement</a> containing the expression was compiled with <a "
"href=\"c3ref/prepare.html\">sqlite3_prepare_v2()</a> or <a href=\"c3ref/"
"prepare.html\">sqlite3_prepare16_v2()</a>.  The LIKE optimization is not "
"attempted if the right-hand side is a <a href=\"lang_expr."
"html#varparam\">parameter</a> and the statement was prepared using <a "
"href=\"c3ref/prepare.html\">sqlite3_prepare()</a> or <a href=\"c3ref/prepare."
"html\">sqlite3_prepare16()</a>."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:546
msgid ""
"Suppose the initial sequence of non-wildcard characters on the right-hand "
"side of the LIKE or GLOB operator is <i>x</i>.  We are using a single "
"character to denote this non-wildcard prefix but the reader should "
"understand that the prefix can consist of more than 1 character.  Let <i>y</"
"i> be the smallest string that is the same length as /x/ but which compares "
"greater than <i>x</i>.  For example, if <i>x</i> is <tt>'hello'</tt> then "
"<i>y</i> would be <tt>'hellp'</tt>.  The LIKE and GLOB optimizations consist "
"of adding two virtual terms like this:"
msgstr ""

#. type: Content of: <html><body><div><p><p><blockquote><pre>
#: sedout/optoverview.html:557
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>column</i><b> &gt;= </b><i>x</i><b> AND </b><i>column</i><b> &lt; </b><i>y</i><b>\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:561
msgid ""
"Under most circumstances, the original LIKE or GLOB operator is still tested "
"against each input row even if the virtual terms are used to constrain an "
"index.  This is because we do not know what additional constraints may be "
"imposed by characters to the right of the <i>x</i> prefix.  However, if "
"there is only a single global wildcard to the right of <i>x</i>, then the "
"original LIKE or GLOB test is disabled.  In other words, if the pattern is "
"like this:"
msgstr ""

#. type: Content of: <html><body><div><p><p><blockquote><pre>
#: sedout/optoverview.html:570
#, no-wrap
msgid ""
"<b>\n"
"  </b><i>column</i><b> LIKE </b><i>x</i><b>%\n"
"  </b><i>column</i><b> GLOB </b><i>x</i><b>*\n"
"</b>"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:575
msgid ""
"then the original LIKE or GLOB tests are disabled when the virtual terms "
"constrain an index because in that case we know that all of the rows "
"selected by the index will pass the LIKE or GLOB test."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:580
msgid ""
"Note that when the right-hand side of a LIKE or GLOB operator is a <a "
"href=\"lang_expr.html#varparam\">parameter</a> and the statement is prepared "
"using <a href=\"c3ref/prepare.html\">sqlite3_prepare_v2()</a> or <a "
"href=\"c3ref/prepare.html\">sqlite3_prepare16_v2()</a> then the statement is "
"automatically reparsed and recompiled on the first <a href=\"c3ref/step."
"html\">sqlite3_step()</a> call of each run if the binding to the right-hand "
"side parameter has changed since the previous run.  This reparse and "
"recompile is essentially the same action that occurs following a schema "
"change.  The recompile is necessary so that the query planner can examine "
"the new value bound to the right-hand side of the LIKE or GLOB operator and "
"determine whether or not to employ the optimization described above.  <a "
"name=\"skipscan\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:593
msgid "<span>6. </span>The Skip-Scan Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:596
msgid ""
"The general rule is that indexes are only useful if there are WHERE-clause "
"constraints on the left-most columns of the index.  However, in some cases, "
"SQLite is able to use an index even if the first few columns of the index "
"are omitted from the WHERE clause but later columns are included."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:605
msgid "Consider a table such as the following:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:607
#, no-wrap
msgid ""
"CREATE TABLE people(\n"
"  name TEXT PRIMARY KEY,\n"
"  role TEXT NOT NULL,\n"
"  height INT NOT NULL, -- in cm\n"
"  CHECK( role IN ('student','teacher') )\n"
");\n"
"CREATE INDEX people_idx1 ON people(role, height);\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:617
msgid ""
"The people table has one entry for each person in a large organization.  "
"Each person is either a \"student\" or a \"teacher\", as determined by the "
"\"role\" field.  The table also records the height in centimeters of each "
"person.  The role and height are indexed.  Notice that the left-most column "
"of the index is not very selective - it only contains two possible values."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:626
msgid ""
"Now consider a query to find the names of everyone in the organization that "
"is 180cm tall or taller:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:630
#, no-wrap
msgid "SELECT name FROM people WHERE height&gt;=180;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:634
msgid ""
"Because the left-most column of the index does not appear in the WHERE "
"clause of the query, one is tempted to conclude that the index is not usable "
"here.  However, SQLite is able to use the index.  Conceptually, SQLite uses "
"the index as if the query were more like the following:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:641
#, no-wrap
msgid ""
"SELECT name FROM people\n"
" WHERE role IN (SELECT DISTINCT role FROM people)\n"
"   AND height&gt;=180;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:647
msgid "Or this:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:649
#, no-wrap
msgid ""
"SELECT name FROM people WHERE role='teacher' AND height&gt;=180\n"
"UNION ALL\n"
"SELECT name FROM people WHERE role='student' AND height&gt;=180;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:655
msgid ""
"The alternative query formulations shown above are conceptual only.  SQLite "
"does not really transform the query.  The actual query plan is like this: "
"SQLite locates the first possible value for \"role\", which it can do by "
"rewinding the \"people_idx1\" index to the beginning and reading the first "
"record.  SQLite stores this first \"role\" value in an internal variable "
"that we will here call \"$role\".  Then SQLite runs a query like: \"SELECT "
"name FROM people WHERE role=$role AND height&gt;=180\".  This query has an "
"equality constraint on the left-most column of the index and so the index "
"can be used to resolve that query.  Once that query is finished, SQLite then "
"uses the \"people_idx1\" index to locate the next value of the \"role\" "
"column, using code that is logically similar to \"SELECT role FROM people "
"WHERE role>$role LIMIT 1\".  This new \"role\" value overwrites the $role "
"variable, and the process repeats until all possible values for \"role\" "
"have been examined."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:672
msgid ""
"We call this kind of index usage a \"skip-scan\" because the database engine "
"is basically doing a full scan of the index but it optimizes the scan "
"(making it less than \"full\") by occasionally skipping ahead to the next "
"candidate value."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:678
msgid ""
"SQLite might use a skip-scan on an index if it knows that the first one or "
"more columns contain many duplication values.  If there are too few "
"duplicates in the left-most columns of the index, then it would be faster to "
"simply step ahead to the next value, and thus do a full table scan, than to "
"do a binary search on an index to locate the next left-column value."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:687
msgid ""
"The only way that SQLite can know that there are many duplicates in the left-"
"most columns of an index is if the <a href=\"lang_analyze.html\">ANALYZE</a> "
"command has been run on the database.  Without the results of ANALYZE, "
"SQLite has to guess at the \"shape\" of the data in the table, and the "
"default guess is that there are an average of 10 duplicates for every value "
"in the left-most column of the index.  Skip-scan only becomes profitable (it "
"only gets to be faster than a full table scan) when the number of duplicates "
"is about 18 or more.  Hence, a skip-scan is never used on a database that "
"has not been analyzed.  <a name=\"joins\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:700
msgid "<span>7. </span>Joins"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:703
msgid ""
"The ON and USING clauses of an inner join are converted into additional "
"terms of the WHERE clause prior to WHERE clause analysis described <a "
"href=\"#where_clause\">above in paragraph 2.0</a>.  Thus with SQLite, there "
"is no computational advantage to use the newer SQL92 join syntax over the "
"older SQL89 comma-join syntax.  They both end up accomplishing exactly the "
"same thing on inner joins."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:712
msgid ""
"For an OUTER JOIN the situation is more complex.  The following two queries "
"are not equivalent:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:715
#, no-wrap
msgid ""
"SELECT * FROM tab1 LEFT JOIN tab2 ON tab1.x=tab2.y;\n"
"SELECT * FROM tab1 LEFT JOIN tab2 WHERE tab1.x=tab2.y;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:719
msgid ""
"For an inner join, the two queries above would be identical.  However, "
"special processing applies to the ON and USING clauses of an OUTER join: "
"specifically, the constraints in an ON or USING clause do not apply if the "
"right table of the join is on a null row, but the constraints do apply in "
"the WHERE clause.  The net effect is that putting the ON or USING clause "
"expressions for a LEFT JOIN in the WHERE clause effectively converts the "
"query to an ordinary INNER JOIN - albeit an inner join that runs more "
"slowly.  <a name=\"table_order\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:730
msgid "<span>7.1. </span>Order of Tables in a Join"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:733
msgid ""
"The current implementation of SQLite uses only loop joins.  That is to say, "
"joins are implemented as nested loops."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:738
msgid ""
"The default order of the nested loops in a join is for the left-most table "
"in the FROM clause to form the outer loop and the right-most table to form "
"the inner loop.  However, SQLite will nest the loops in a different order if "
"doing so will help it to select better indexes."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:745
msgid ""
"Inner joins can be freely reordered.  However a left outer join is neither "
"commutative nor associative and hence will not be reordered.  Inner joins to "
"the left and right of the outer join might be reordered if the optimizer "
"thinks that is advantageous but the outer joins are always evaluated in the "
"order in which they occur."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:752
msgid ""
"SQLite <a href=\"lang_select.html#crossjoin\">treats the CROSS JOIN operator "
"specially</a>.  The CROSS JOIN operator is commutative, in theory.  However, "
"SQLite chooses to never reorder tables in a CROSS JOIN.  This provides a "
"mechanism by which the programmer can force SQLite to choose a particular "
"loop nesting order."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:759
msgid ""
"When selecting the order of tables in a join, SQLite uses an efficient "
"polynomial-time algorithm.  Because of this, SQLite is able to plan queries "
"with 50- or 60-way joins in a matter of microseconds"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:765
msgid ""
"Join reordering is automatic and usually works well enough that programmers "
"do not have to think about it, especially if <a href=\"lang_analyze."
"html\">ANALYZE</a> has been used to gather statistics about the available "
"indexes, though occasionally some hints from the programmer are needed.  "
"Consider, for example, the following schema:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:771
#, no-wrap
msgid ""
"CREATE TABLE node(\n"
"   id INTEGER PRIMARY KEY,\n"
"   name TEXT\n"
");\n"
"CREATE INDEX node_idx ON node(name);\n"
"CREATE TABLE edge(\n"
"   orig INTEGER REFERENCES node,\n"
"   dest INTEGER REFERENCES node,\n"
"   PRIMARY KEY(orig, dest)\n"
");\n"
"CREATE INDEX edge_idx ON edge(dest,orig);\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:784
msgid ""
"The schema above defines a directed graph with the ability to store a name "
"at each node. Now consider a query against this schema:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:787
#, no-wrap
msgid ""
"SELECT *\n"
"  FROM edge AS e,\n"
"       node AS n1,\n"
"       node AS n2\n"
" WHERE n1.name = 'alice'\n"
"   AND n2.name = 'bob'\n"
"   AND e.orig = n1.id\n"
"   AND e.dest = n2.id;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:797
msgid ""
"This query asks for is all information about edges that go from nodes "
"labeled \"alice\" to nodes labeled \"bob\".  The query optimizer in SQLite "
"has basically two choices on how to implement this query.  (There are "
"actually six different choices, but we will only consider two of them "
"here.)  Pseudocode below demonstrating these two choices.  <a "
"name=\"option1\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:806
msgid "Option 1:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:807
#, no-wrap
msgid ""
"foreach n1 where n1.name='alice' do:\n"
"  foreach n2 where n2.name='bob' do:\n"
"    foreach e where e.orig=n1.id and e.dest=n2.id\n"
"      return n1.*, n2.*, e.*\n"
"    end\n"
"  end\n"
"end\n"
msgstr ""

#. type: Content of: <html><body><div><p>
#: sedout/optoverview.html:815
msgid "<a name=\"option2\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:817
msgid "Option 2:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:818
#, no-wrap
msgid ""
"foreach n1 where n1.name='alice' do:\n"
"  foreach e where e.orig=n1.id do:\n"
"    foreach n2 where n2.id=e.dest and n2.name='bob' do:\n"
"      return n1.*, n2.*, e.*\n"
"    end\n"
"  end\n"
"end\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:827
msgid ""
"The same indexes are used to speed up every loop in both implementation "
"options.  The only difference in these two query plans is the order in which "
"the loops are nested."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:833
msgid ""
"So which query plan is better? It turns out that the answer depends on what "
"kind of data is found in the node and edge tables."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:837
msgid ""
"Let the number of alice nodes be M and the number of bob nodes be N.  "
"Consider two scenarios. In the first scenario, M and N are both 2 but there "
"are thousands of edges on each node. In this case, option 1 is preferred. "
"With option 1, the inner loop checks for the existence of an edge between a "
"pair of nodes and outputs the result if found.  Because there are only 2 "
"alice and bob nodes each, the inner loop only has to run four times and the "
"query is very quick. Option 2 would take much longer here. The outer loop of "
"option 2 only executes twice, but because there are a large number of edges "
"leaving each alice node, the middle loop has to iterate many thousands of "
"times. It will be much slower. So in the first scenario, we prefer to use "
"option 1."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:850
msgid ""
"Now consider the case where M and N are both 3500. Alice nodes are "
"abundant.  This time suppose each of these nodes is connected by only one or "
"two edges. Now option 2 is preferred. With option 2, the outer loop still "
"has to run 3500 times, but the middle loop only runs once or twice for each "
"outer loop and the inner loop will only run once for each middle loop, if at "
"all. So the total number of iterations of the inner loop is around 7000. "
"Option 1, on the other hand, has to run both its outer loop and its middle "
"loop 3500 times each, resulting in 12 million iterations of the middle "
"loop.  Thus in the second scenario, option 2 is nearly 2000 times faster "
"than option 1."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:863
msgid ""
"So you can see that depending on how the data is structured in the table, "
"either query plan 1 or query plan 2 might be better.  Which plan does SQLite "
"choose by default? As of version 3.6.18, without running <a "
"href=\"lang_analyze.html\">ANALYZE</a>, SQLite will choose option 2.  If the "
"<a href=\"lang_analyze.html\">ANALYZE</a> command is run in order to gather "
"statistics, a different choice might be made if the statistics indicate that "
"the alternative is likely to run faster.  <a name=\"manctrl\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:873
msgid ""
"<span>7.2. </span>Manual Control Of Query Plans Using SQLITE_STAT Tables"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:876
msgid ""
"SQLite provides the ability for advanced programmers to exercise control "
"over the query plan chosen by the optimizer. One method for doing this is to "
"fudge the <a href=\"lang_analyze.html\">ANALYZE</a> results in the <a "
"href=\"fileformat2.html#stat1tab\">sqlite_stat1</a>, <a href=\"fileformat2."
"html#stat3tab\">sqlite_stat3</a>, and/or <a href=\"fileformat2."
"html#stat4tab\">sqlite_stat4</a> tables.  This is not recommended for most "
"situations.  <a name=\"crossjoin\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:884
msgid "<span>7.3. </span>Manual Control of Query Plans using CROSS JOIN"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:887
msgid ""
"Programmers can force SQLite to use a particular loop nesting order for a "
"join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, "
"NATURAL JOIN, or a \",\" join.  Though CROSS JOINs are commutative in "
"theory, SQLite chooses to never reorder the tables in a CROSS JOIN.  Hence, "
"the left table of a CROSS JOIN will always be in an outer loop relative to "
"the right table."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:895
msgid ""
"In the following query, the optimizer is free to reorder the tables of FROM "
"clause any way it sees fit:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:898
#, no-wrap
msgid ""
"SELECT *\n"
"  FROM node AS n1,\n"
"       edge AS e,\n"
"       node AS n2\n"
" WHERE n1.name = 'alice'\n"
"   AND n2.name = 'bob'\n"
"   AND e.orig = n1.id\n"
"   AND e.dest = n2.id;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:908
msgid ""
"In the following logically equivalent formulation of the same query, the "
"substitution of \"CROSS JOIN\" for the \",\" means that the order of tables "
"must be N1, E, N2."
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:912
#, no-wrap
msgid ""
"SELECT *\n"
"  FROM node AS n1 CROSS JOIN\n"
"       edge AS e CROSS JOIN\n"
"       node AS n2\n"
" WHERE n1.name = 'alice'\n"
"   AND n2.name = 'bob'\n"
"   AND e.orig = n1.id\n"
"   AND e.dest = n2.id;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:922
msgid ""
"In the latter query, the query plan must be <a href=\"#option2\">option 2</"
"a>.  Note that you must use the keyword \"CROSS\" in order to disable the "
"table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other "
"similar combinations work just like a comma join in that the optimizer is "
"free to reorder tables as it sees fit. (Table reordering is also disabled on "
"an outer join, but that is because outer joins are not associative or "
"commutative. Reordering tables in OUTER JOIN changes the result.)"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:933
msgid ""
"See \"<a href=\"queryplanner-ng.html#fossilcasestudy\">The Fossil NGQP "
"Upgrade Case Study</a>\" for another real-world example of using CROSS JOIN "
"to manually control the nesting order of a join.  The <a href=\"queryplanner-"
"ng.html#howtofix\">query planner checklist</a> found later in the same "
"document provides further guidance on manual control of the query planner.  "
"<a name=\"multi_index\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:940
msgid "<span>8. </span>Choosing Between Multiple Indexes"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:943
msgid ""
"Each table in the FROM clause of a query can use at most one index (except "
"when the <a href=\"#or_opt\">OR-clause optimization</a> comes into play)  "
"and SQLite strives to use at least one index on each table.  Sometimes, two "
"or more indexes might be candidates for use on a single table.  For example:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:950
#, no-wrap
msgid ""
"CREATE TABLE ex2(x,y,z);\n"
"CREATE INDEX ex2i1 ON ex2(x);\n"
"CREATE INDEX ex2i2 ON ex2(y);\n"
"SELECT z FROM ex2 WHERE x=5 AND y=6;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:956
msgid ""
"For the SELECT statement above, the optimizer can use the ex2i1 index to "
"lookup rows of ex2 that contain x=5 and then test each row against the y=6 "
"term.  Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 "
"then test each of those rows against the x=5 term."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:963
msgid ""
"When faced with a choice of two or more indexes, SQLite tries to estimate "
"the total amount of work needed to perform the query using each option.  It "
"then selects the option that gives the least estimated work."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:968
msgid ""
"To help the optimizer get a more accurate estimate of the work involved in "
"using various indexes, the user may optionally run the <a "
"href=\"lang_analyze.html\">ANALYZE</a> command.  The <a href=\"lang_analyze."
"html\">ANALYZE</a> command scans all indexes of database where there might "
"be a choice between two or more indexes and gathers statistics on the "
"selectiveness of those indexes.  The statistics gathered by this scan are "
"stored in special database tables names shows names all begin with "
"\"<b>sqlite_stat</b>\".  The content of these tables is not updated as the "
"database changes so after making significant changes it might be prudent to "
"rerun <a href=\"lang_analyze.html\">ANALYZE</a>.  The results of an ANALYZE "
"command are only available to database connections that are opened after the "
"ANALYZE command completes."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:982
msgid ""
"The various <b>sqlite_stat</b><i>N</i> tables contain information on how "
"selective the various indexes are.  For example, the <a href=\"fileformat2."
"html#stat1tab\">sqlite_stat1</a> table might indicate that an equality "
"constraint on column x reduces the search space to 10 rows on average, "
"whereas an equality constraint on column y reduces the search space to 3 "
"rows on average.  In that case, SQLite would prefer to use index ex2i2 since "
"that index is more selective.  <a name=\"uplus\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:991
msgid "<span>8.1. </span>Disqualifying WHERE Clause Terms using Unary-\"+\""
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:994
msgid ""
"Terms of the WHERE clause can be manually disqualified for use with indexes "
"by prepending a unary <b>+</b> operator to the column name.  The unary <b>+</"
"b> is a no-op and will not generate any byte code in the prepared "
"statement.  However, the unary <b>+</b> operator will prevent the term from "
"constraining an index.  So, in the example above, if the query were "
"rewritten as:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:1002
#, no-wrap
msgid "SELECT z FROM ex2 WHERE +x=5 AND y=6;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1005
msgid ""
"The <b>+</b> operator on the <b>x</b> column will prevent that term from "
"constraining an index.  This would force the use of the ex2i2 index."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1009
msgid ""
"Note that the unary <b>+</b> operator also removes <a href=\"datatype3."
"html#affinity\">type affinity</a> from an expression, and in some cases this "
"can cause subtle changes in the meaning of an expression.  In the example "
"above, if column <b>x</b> has <a href=\"datatype3.html#affinity\">TEXT "
"affinity</a> then the comparison \"x=5\" will be done as text.  The <b>+</b> "
"operator removes the affinity.  So the comparison \"<b>+x=5</b>\" will "
"compare the text in column <b>x</b> with the numeric value 5 and will always "
"be false.  <a name=\"rangequery\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:1021
msgid "<span>8.2. </span>Range Queries"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1024
msgid "Consider a slightly different scenario:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:1026
#, no-wrap
msgid ""
"CREATE TABLE ex2(x,y,z);\n"
"CREATE INDEX ex2i1 ON ex2(x);\n"
"CREATE INDEX ex2i2 ON ex2(y);\n"
"SELECT z FROM ex2 WHERE x BETWEEN 1 AND 100 AND y BETWEEN 1 AND 100;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1032
msgid ""
"Further suppose that column x contains values spread out between 0 and "
"1,000,000 and column y contains values that span between 0 and 1,000.  In "
"that scenario, the range constraint on column x should reduce the search "
"space by a factor of 10,000 whereas the range constraint on column y should "
"reduce the search space by a factor of only 10.  So the ex2i1 index should "
"be preferred."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1041
msgid ""
"SQLite will make this determination, but only if it has been compiled with "
"<a href=\"compile.html#enable_stat3\">SQLITE_ENABLE_STAT3</a> or <a "
"href=\"compile.html#enable_stat4\">SQLITE_ENABLE_STAT4</a>.  The <a "
"href=\"compile.html#enable_stat3\">SQLITE_ENABLE_STAT3</a> and <a "
"href=\"compile.html#enable_stat4\">SQLITE_ENABLE_STAT4</a> options causes "
"the <a href=\"lang_analyze.html\">ANALYZE</a> command to collect a histogram "
"of column content in the <a href=\"fileformat2.html#stat3tab\">sqlite_stat3</"
"a> or <a href=\"fileformat2.html#stat4tab\">sqlite_stat4</a> tables and to "
"use this histogram to make a better guess at the best query to use for range "
"constraints such as the above.  The main difference between STAT3 and STAT4 "
"is that STAT3 records histogram data for only the left-most column of an "
"index whereas STAT4 records histogram data for all columns of an index.  For "
"single-column indexes, STAT3 and STAT4 work the same."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1053
msgid ""
"The histogram data is only useful if the right-hand side of the constraint "
"is a simple compile-time constant or <a href=\"lang_expr."
"html#varparam\">parameter</a> and not an expression."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1057
msgid ""
"Another limitation of the histogram data is that it only applies to the left-"
"most column on an index.  Consider this scenario:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:1060
#, no-wrap
msgid ""
"CREATE TABLE ex3(w,x,y,z);\n"
"CREATE INDEX ex3i1 ON ex2(w, x);\n"
"CREATE INDEX ex3i2 ON ex2(w, y);\n"
"SELECT z FROM ex3 WHERE w=5 AND x BETWEEN 1 AND 100 AND y BETWEEN 1 AND 100;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1066
msgid ""
"Here the inequalities are on columns x and y which are not the left-most "
"index columns.  Hence, the histogram data which is collected no left-most "
"column of indexes is useless in helping to choose between the range "
"constraints on columns x and y.  <a name=\"covidx\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:1073
msgid "<span>9. </span>Covering Indexes"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1076
msgid ""
"When doing an indexed lookup of a row, the usual procedure is to do a binary "
"search on the index to find the index entry, then extract the <a "
"href=\"lang_createtable.html#rowid\">rowid</a> from the index and use that "
"<a href=\"lang_createtable.html#rowid\">rowid</a> to do a binary search on "
"the original table.  Thus a typical indexed lookup involves two binary "
"searches.  If, however, all columns that were to be fetched from the table "
"are already available in the index itself, SQLite will use the values "
"contained in the index and will never look up the original table row.  This "
"saves one binary search for each row and can make many queries run twice as "
"fast."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1088
msgid ""
"When an index contains all of the data needed for a query and when the "
"original table never needs to be consulted, we call that index a \"covering "
"index\".  <a name=\"order_by\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:1094
msgid "<span>10. </span>ORDER BY Optimizations"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1097
msgid ""
"SQLite attempts to use an index to satisfy the ORDER BY clause of a query "
"when possible.  When faced with the choice of using an index to satisfy "
"WHERE clause constraints or satisfying an ORDER BY clause, SQLite does the "
"same cost analysis described above and chooses the index that it believes "
"will result in the fastest answer."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1105
msgid ""
"SQLite will also attempt to use indexes to help satisfy GROUP BY clauses and "
"the DISTINCT keyword.  If the nested loops of the join can be arranged such "
"that rows that are equivalent for the GROUP BY or for the DISTINCT are "
"consecutive, then the GROUP BY or DISTINCT logic can determine if the "
"current row is part of the same group or if the current row is distinct "
"simply by comparing the current row to the previous row.  This can be much "
"faster than the alternative of comparing each row to all prior rows.  <a "
"name=\"partsort\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h2>
#: sedout/optoverview.html:1116
msgid "<span>10.1. </span>Partial ORDER BY via Index"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1119
msgid ""
"If a query contains an ORDER BY clause with multiple terms, it might be that "
"SQLite can use indexes to cause rows to come out in the order of some prefix "
"of the terms in the ORDER BY but that later terms in the ORDER BY are not "
"satisfied.  In that case, SQLite does block sorting.  Suppose the ORDER BY "
"clause has four terms and the natural order of the query results in rows "
"appearing in order of the first two terms.  As each row is output by the "
"query engine and enters the sorter, the outputs in the current row "
"corresponding to the first two terms of the ORDER BY are compared against "
"the previous row.  If they have changed, the current sort is finished and "
"output and a new sort is started.  This results in a slightly faster sort.  "
"Event bigger advantages are that many fewer rows need to be held in memory, "
"reducing memory requirements, and outputs can begin to appear before the "
"core query has run to completion.  <a name=\"flattening\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><h1>
#: sedout/optoverview.html:1136
msgid "<span>11. </span>Subquery Flattening"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1139
msgid ""
"When a subquery occurs in the FROM clause of a SELECT, the simplest behavior "
"is to evaluate the subquery into a transient table, then run the outer "
"SELECT against the transient table.  Such a plan can be suboptimal since the "
"transient table will not have any indexes and the outer query (which is "
"likely a join) will be forced to do a full table scan on the transient table."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1147
msgid ""
"To overcome this problem, SQLite attempts to flatten subqueries in the FROM "
"clause of a SELECT.  This involves inserting the FROM clause of the subquery "
"into the FROM clause of the outer query and rewriting expressions in the "
"outer query that refer to the result set of the subquery.  For example:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:1154
#, no-wrap
msgid "SELECT t1.a, t2.b FROM t2, (SELECT x+y AS a FROM t1 WHERE z&lt;100) WHERE a&gt;5\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1157
msgid "Would be rewritten using query flattening as:"
msgstr ""

#. type: Content of: <html><body><div><p><div><pre>
#: sedout/optoverview.html:1159
#, no-wrap
msgid "SELECT t1.x+t1.y AS a, t2.b FROM t2, t1 WHERE z&lt;100 AND a&gt;5\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1162
msgid ""
"There is a long list of conditions that must all be met in order for query "
"flattening to occur.  Some of the constraints are marked as obsolete by "
"italic text.  These extra constraints are retained in the documentation to "
"preserve the numbering of the other constraints."
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1168
msgid ""
"Casual readers are not expected to understand all of these rules.  A key "
"take-away from this section is that the rules for determining if query "
"flatting is safe or unsafe are subtle and complex.  There have been multiple "
"bugs over the years caused by over-aggressive query flattening.  On the "
"other hand, performance of complex queries and/or queries involving views "
"tends to suffer if query flattening is more conservative."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1178 sedout/optoverview.html:1181
#: sedout/optoverview.html:1195
msgid ""
"<i>(Obsolete.  Query flattening is no longer attempted for aggregate "
"subqueries.)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1185
msgid "If the subquery is the right operand of a LEFT JOIN then"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1186
msgid "the subquery may not be a join, and"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1187
msgid "the FROM clause of the subquery may not contain a virtual table, and"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1189
msgid "the outer query may not be an aggregate."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1191
msgid "The subquery is not DISTINCT."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1193
msgid "<i>(Subsumed into constraint 4)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1199
msgid "The subquery has a FROM clause."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1202
msgid "The subquery does not use LIMIT or the outer query is not a join."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1205
msgid ""
"The subquery does not use LIMIT or the outer query does not use aggregates."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1208
msgid "<i>(Restriction relaxed in 2005)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1211
msgid "The subquery and the outer query do not both have ORDER BY clauses."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1213
msgid "<i>(Subsumed into constraint 3)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1215
msgid "The subquery and outer query do not both use LIMIT."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1217
msgid "The subquery does not use OFFSET."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1220
msgid ""
"If the outer query is part of a compound select, then the subquery may not "
"have a LIMIT clause."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1224
msgid ""
"If the outer query is an aggregate, then the subquery may not contain ORDER "
"BY."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1228
msgid "If the sub-query is a compound SELECT, then"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1230
msgid "all compound operators must be UNION ALL, and"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1231
msgid "no terms with the subquery compound may be aggregate or DISTINCT, and"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1233
msgid "every term within the subquery must have a FROM clause, and"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li><ol><li>
#: sedout/optoverview.html:1234
msgid "the outer query may not be an aggregate, DISTINCT query, or join."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1237
msgid ""
"The parent and sub-query may contain WHERE clauses. Subject to rules (11), "
"(12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1242
msgid ""
"If the sub-query is a compound select, then all terms of the ORDER by clause "
"of the parent must be simple references to columns of the sub-query."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1247
msgid ""
"If the subquery uses LIMIT then the outer query may not have a WHERE clause."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1251
msgid ""
"If the sub-query is a compound select, then it must not use an ORDER BY "
"clause."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1255
msgid "If the subquery uses LIMIT, then the outer query may not be DISTINCT."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1258
msgid "The subquery may not be a recursive CTE."
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1260
msgid "<i>(Subsumed into constraint 17d.)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><ol><li>
#: sedout/optoverview.html:1262
msgid ""
"<i>(Obsolete. Query flattening is no longer attempted for aggregate "
"subqueries.)</i>"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1268
msgid ""
"Query flattening is an important optimization when views are used as each "
"use of a view is translated into a subquery.  <a name=\"coroutines\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1273
msgid "<span>12. </span>Subquery Co-routines"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1276
msgid ""
"Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be "
"either flattened into the outer query, or else the subquery would be run to "
"completion before the outer query started, the result set from the subquery "
"would be stored in a transient table, and then the transient table would be "
"used in the outer query.  Newer versions of SQLite have a third option, "
"which is to implement the subquery using a co-routine."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1287
msgid ""
"A co-routine is like a subroutine in that it runs in the same thread as the "
"caller and eventually returns control back to the caller.  The difference is "
"that a co-routine also has the ability to return before it has finished, and "
"then resume where it left off the next time it is called."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1294
msgid ""
"When a subquery is implemented as a co-routine, byte-code is generated to "
"implement the subquery as if it were a standalone query, except instead of "
"returning rows of results back to the application, the co-routine yields "
"control back to the caller after each row is computed.  The caller can then "
"use that one computed row as part of its computation, then invoke the co-"
"routine again when it is ready for the next row."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1302
msgid ""
"Co-routines are better than storing the complete result set of the subquery "
"in a transient table because co-routines use less memory.  With a co-"
"routine, only a single row of the result needs to be remembered, whereas all "
"rows of the result must be stored for a transient table.  Also, because the "
"co-routine does not need to run to completion before the outer query begins "
"its work, the first rows of output can appear much sooner, and if the "
"overall query is abandoned before it has finished, less work is done overall."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1312
msgid ""
"On the other hand, if the result of the subquery must be scanned multiple "
"times (because, for example, it is just one table in a join) then it is "
"better to use a transient table to remember the entire result of the "
"subquery, in order to avoid computing the subquery more than once.  <a "
"name=\"deferred_work\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h2>
#: sedout/optoverview.html:1319
msgid ""
"<span>12.1. </span>Using Co-routines to Defer Work until after the Sorting"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1322
msgid ""
"As of SQLite version 3.21.0 (2017-10-24), the query planner will always "
"prefer to use a co-routine to implement FROM-clause subqueries that contains "
"an ORDER BY clause and that are not part of a join when the result set of "
"the outer query is \"complex\".  This feature allows applications to shift "
"expensive computations from before the sorter until after the sorter, which "
"can result in faster operation.  For example, consider this query:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1330
#, no-wrap
msgid "SELECT expensive_function(a) FROM tab ORDER BY date DESC LIMIT 5;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1333
msgid ""
"The goal of this query is to compute some value for the five most recent "
"entries in the table.  In the query above, the \"expensive_function()\" is "
"invoked prior to the sort and thus is invoked on every row of the table, "
"even rows that are ultimately omitted due to the LIMIT clause.  A co-routine "
"can be used to work around this:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1340
#, no-wrap
msgid ""
"SELECT expensive_function(a) FROM (\n"
"  SELECT a FROM tab ORDER BY date DESC LIMIT 5\n"
");\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1345
msgid ""
"In the revised query, the subquery implemented by a co-routine computes the "
"five most recent values for \"a\".  Those five values are passed from the co-"
"routine up into the outer query where the \"expensive_function()\" is "
"invoked on only the specific rows that the application cares about."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1351
msgid ""
"The query planner in future versions of SQLite might grow smart enough to "
"make transformations such as the above automatically, in both directions.  "
"That is to say, future versions of SQLite might transform queries of the "
"first form into the second, or queries written the second way into the "
"first.  As of SQLite version 3.22.0 (2018-01-22), the query planner will "
"flatten the subquery if the outer query does not make use of any user-"
"defined functions or subqueries in its result set.  For the examples shown "
"above, however, SQLite implements each of the queries as written.  <a "
"name=\"minmax\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1363
msgid "<span>13. </span>The MIN/MAX Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1366
msgid ""
"Queries that contain a single MIN() or MAX() aggregate function whose "
"argument is the left-most column of an index might be satisfied by doing a "
"single index lookup rather than by scanning the entire table.  Examples:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1371
#, no-wrap
msgid ""
"SELECT MIN(x) FROM table;\n"
"SELECT MAX(x)+1 FROM table;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p>
#: sedout/optoverview.html:1375
msgid "<a name=\"autoindex\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1377
msgid "<span>14. </span>Automatic Indexes"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1380
msgid ""
"When no indexes are available to aid the evaluation of a query, SQLite might "
"create an automatic index that lasts only for the duration of a single SQL "
"statement.  Since the cost of constructing the automatic index is O(NlogN) "
"(where N is the number of entries in the table) and the cost of doing a full "
"table scan is only O(N), an automatic index will only be created if SQLite "
"expects that the lookup will be run more than logN times during the course "
"of the SQL statement. Consider an example:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1389
#, no-wrap
msgid ""
"CREATE TABLE t1(a,b);\n"
"CREATE TABLE t2(c,d);\n"
"-- Insert many rows into both t1 and t2\n"
"SELECT * FROM t1, t2 WHERE a=c;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1395
msgid ""
"In the query above, if both t1 and t2 have approximately N rows, then "
"without any indexes the query will require O(N*N) time.  On the other hand, "
"creating an index on table t2 requires O(NlogN) time and using that index to "
"evaluate the query requires an additional O(NlogN) time.  In the absence of "
"<a href=\"lang_analyze.html\">ANALYZE</a> information, SQLite guesses that N "
"is one million and hence it believes that constructing the automatic index "
"will be the cheaper approach."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1404
msgid "An automatic index might also be used for a subquery:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1406
#, no-wrap
msgid ""
"CREATE TABLE t1(a,b);\n"
"CREATE TABLE t2(c,d);\n"
"-- Insert many rows into both t1 and t2\n"
"SELECT a, (SELECT d FROM t2 WHERE c=b) FROM t1;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1412
msgid ""
"In this example, the t2 table is used in a subquery to translate values of "
"the t1.b column.  If each table contains N rows, SQLite expects that the "
"subquery will run N times, and hence it will believe it is faster to "
"construct an automatic, transient index on t2 first and then use that index "
"to satisfy the N instances of the subquery."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1419
msgid ""
"The automatic indexing capability can be disabled at run-time using the <a "
"href=\"pragma.html#pragma_automatic_index\">automatic_index pragma</a>.  "
"Automatic indexing is turned on by default, but this can be changed so that "
"automatic indexing is off by default using the <a href=\"compile."
"html#default_automatic_index\">SQLITE_DEFAULT_AUTOMATIC_INDEX</a> compile-"
"time option.  The ability to create automatic indexes can be completely "
"disabled by compiling with the <a href=\"compile."
"html#omit_automatic_index\">SQLITE_OMIT_AUTOMATIC_INDEX</a> compile-time "
"option."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1427
msgid ""
"In SQLite <a href=\"releaselog/3_8_0.html\">version 3.8.0</a> (2013-08-26) "
"and later, an <a href=\"rescode."
"html#warning_autoindex\">SQLITE_WARNING_AUTOINDEX</a> message is sent to the "
"<a href=\"errlog.html\">error log</a> every time a statement is prepared "
"that uses an automatic index.  Application developers can and should use "
"these warnings to identify the need for new persistent indexes in the schema."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1434
msgid ""
"Do not confuse automatic indexes with the <a href=\"fileformat2."
"html#intschema\">internal indexes</a> (having names like "
"\"sqlite_autoindex_<i>table</i>_<i>N</i>\") that are sometimes created to "
"implement a <a href=\"lang_createtable.html#primkeyconst\">PRIMARY KEY "
"constraint</a> or <a href=\"lang_createtable.html#uniqueconst\">UNIQUE "
"constraint</a>.  The automatic indexes described here exist only for the "
"duration of a single query, are never persisted to disk, and are only "
"visible to a single database connection.  Internal indexes are part of the "
"implementation of PRIMARY KEY and UNIQUE constraints, are long-lasting and "
"persisted to disk, and are visible to all database connections.  The term "
"\"autoindex\" appears in the names of <a href=\"fileformat2."
"html#intschema\">internal indexes</a> for legacy reasons and does not "
"indicate that internal indexes and automatic indexes are related.  <a "
"name=\"hashjoin\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h2>
#: sedout/optoverview.html:1447
msgid "<span>14.1. </span>Hash Joins"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1450
msgid ""
"An automatic index is about the same thing as a <a href=\"https://en."
"wikipedia.org/wiki/Hash_join\">hash join</a>.  The only difference is that a "
"B-Tree is used instead of a hash table.  If you are willing to say that the "
"transient B-Tree constructed for an automatic index is really just a fancy "
"hash table, then a query that uses an automatic index is just a hash join."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1458
msgid ""
"SQLite constructs a transient index instead of a hash table in this instance "
"because it already has a robust and high performance B-Tree implementation "
"at hand, whereas a hash-table would need to be added.  Adding a separate "
"hash table implementation to handle this one case would increase the size of "
"the library (which is designed for use on low-memory embedded devices) for "
"minimal performance gain.  SQLite might be enhanced with a hash-table "
"implementation someday, but for now it seems better to continue using "
"automatic indexes in cases where client/server database engines might use a "
"hash join.  <a name=\"pushdown\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1470
msgid "<span>15. </span>The Push-Down Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1473
msgid ""
"If a subquery cannot be <a href=\"optoverview.html#flattening\">flattened</"
"a> into the outer query, it might still be possible to enhance performance "
"by \"pushing down\" WHERE clause terms from the outer query into the "
"subquery.  Consider an example:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1477
#, no-wrap
msgid ""
"CREATE TABLE t1(a INT, b INT);\n"
"CREATE TABLE t2(x INT, y INT);\n"
"CREATE VIEW v1(a,b) AS SELECT DISTINCT a, b FROM t1;\n"
"\n"
"SELECT x, y, b\n"
"  FROM t2 JOIN v1 ON (x=a)\n"
" WHERE b BETWEEN 10 AND 20;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1487
msgid ""
"The view v1 cannot be <a href=\"optoverview.html#flattening\">flattened</a> "
"because it is DISTINCT.  It must instead be run as a subquery with the "
"results being stored in a transient table, then the join is performed "
"between t2 and the transient table.  The push-down optimization pushes down "
"the \"b BETWEEN 10 AND 20\" term into the view.  This makes the transient "
"table smaller, and helps the subquery to run faster if there is an index on "
"t1.b.  The resulting evaluation is like this:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1495
#, no-wrap
msgid ""
"SELECT x, y, b\n"
"  FROM t2\n"
"  JOIN (SELECT DISTINCT a, b FROM t1 WHERE b BETWEEN 10 AND 20)\n"
" WHERE b BETWEEN 10 AND 20;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1502
msgid ""
"The push-down optimization cannot always be used.  For example, if the "
"subquery contains a LIMIT, then pushing down any part of the WHERE clause "
"from the outer query could change the result of the inner query.  There are "
"other restrictions, explained in a comment in the source code on the "
"pushDownWhereTerms() routine that implements this optimization.  <a "
"name=\"leftjoinreduction\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1511
msgid "<span>16. </span>The LEFT JOIN Strength Reduction Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1514
msgid ""
"A LEFT JOIN can sometimes be converted into an ordinary JOIN if there are "
"terms in the WHERE clause that guarantee that the two joins will give "
"identical results.  In particular, if any column in the right-hand table of "
"the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, "
"then the LEFT JOIN is demoted to an ordinary JOIN."
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1522
msgid ""
"The prover that determines whether any column of the right-hand table of a "
"LEFT JOIN must be non-NULL in the WHERE clause is imperfect.  It sometimes "
"returns a false negative.  In other words, it sometimes fails to reduce the "
"strength of a LEFT JOIN when doing so was in fact possible.  For example, "
"the prover does not know the <a href=\"lang_datefunc.html\">datetime() SQL "
"function</a> will always return NULL if its first argument is NULL, and so "
"it will not recognize that the LEFT JOIN in the following query could be "
"strength-reduced:"
msgstr ""

#. type: Content of: <html><body><div><p><p><div><pre>
#: sedout/optoverview.html:1531
#, no-wrap
msgid ""
"SELECT urls.url\n"
"  FROM urls\n"
"  LEFT JOIN\n"
"    (SELECT *\n"
"      FROM (SELECT url_id AS uid, max(retrieval_time) AS rtime\n"
"              FROM lookups GROUP BY 1 ORDER BY 1)\n"
"      WHERE uid IN (358341,358341,358341)\n"
"    ) recent\n"
"    ON u.source_seed_id = recent.xyz OR u.url_id = recent.xyz\n"
" WHERE\n"
"     DATETIME(recent.rtime) &gt; DATETIME('now', '-5 days');\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1545
msgid ""
"It is possible that future enhancements to the prover might enable it to "
"recognize that NULL inputs to certain built-in functions always result in a "
"NULL answer.  However, not all built-in functions have that property (for "
"example <a href=\"lang_corefunc.html#coalesce\">coalesce()</a>) and, of "
"course, the prover will never be able to reason about <a href=\"appfunc."
"html\">application-defined SQL functions</a>.  <a name=\"omitnoopjoin\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><h1>
#: sedout/optoverview.html:1555
msgid "<span>17. </span>The Omit LEFT JOIN Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1558
msgid ""
"Sometimes a LEFT JOIN can be completely omitted from a query without "
"changing the result.  This can happen if all of the following are true:"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><ol><li>
#: sedout/optoverview.html:1564
msgid "The query is not an aggregate"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><ol><li>
#: sedout/optoverview.html:1565
msgid ""
"Either the query is DISTINCT or else the ON or USING clause on the LEFT JOIN "
"constrains the join such that it matches only a single row"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><ol><li>
#: sedout/optoverview.html:1568
msgid ""
"The right-hand table of the LEFT JOIN is not be used anywhere in the query "
"outside of its own USING or ON clause."
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1573
msgid ""
"LEFT JOIN elimination often comes up when LEFT JOINs are used inside of "
"views, and then the view is used in such as way that none of the columns of "
"the right-hand table of the LEFT JOIN are referenced."
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1579
msgid "Here is a simple example of omitting a LEFT JOIN:"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><div><pre>
#: sedout/optoverview.html:1581
#, no-wrap
msgid ""
"CREATE TABLE t1(ipk INTEGER PRIMARY KEY, v1);\n"
"CREATE TABLE t2(ipk INTEGER PRIMARY KEY, v2);\n"
"CREATE TABLE t3(ipk INTEGER PRIMARY KEY, v3);\n"
"\n"
"SELECT v1, v3 FROM t1 \n"
"  LEFT JOIN t2 ON (t1.ipk=t2.ipk)\n"
"  LEFT JOIN t3 ON (t1.ipk=t3.ipk)\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1591
msgid ""
"The t2 table is completely unused in the query above, and so the query "
"planner is able to implement the query as if it were written:"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><div><pre>
#: sedout/optoverview.html:1594
#, no-wrap
msgid ""
"SELECT v1, v3 FROM t1 \n"
"  LEFT JOIN t3 ON (t1.ipk=t3.ipk)\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p>
#: sedout/optoverview.html:1599
msgid "<a name=\"constprop\"></a>"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><h1>
#: sedout/optoverview.html:1601
msgid "<span>18. </span>The Constant Propagation Optimization"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1604
msgid ""
"When a WHERE clause contains two or more equality constraints connected by "
"the AND operator such that all of the <a href=\"datatype3."
"html#affinity\">affinities</a> of the various constraints are the same, then "
"SQLite might use the transitive property of equality to construct new "
"\"virtual\" constraints that can be used to simplify expressions and/or "
"improve performance.  This is called the \"constant-propagation "
"optimization\"."
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1612
msgid "For example, consider the following schema and query:"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><div><pre>
#: sedout/optoverview.html:1614
#, no-wrap
msgid ""
"CREATE TABLE t1(a INTEGER PRIMARY KEY, b INT, c INT);\n"
"SELECT * FROM t1 WHERE a=b AND b=5;\n"
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1619
msgid ""
"SQLite looks at the \"a=b\" and \"b=5\" constraints and deduces that if "
"those two constraints are true, then it must also be the case that \"a=5\" "
"is true.  This means that the desired row can be looked up quickly using a "
"value of 5 for the INTEGER PRIMARY KEY."
msgstr ""

#. type: Content of: <html><body><div><p><p><p><p>
#: sedout/optoverview.html:1623
msgid ""
"<small><i>This page last modified on <a href=\"https://sqlite.org/docsrc/"
"honeypot\" id=\"mtimelink\" data-href=\"https://sqlite.org/docsrc/finfo/"
"pages/optoverview.in?m=2d4bcf2cf8\">2023-02-27 02:07:35</a> UTC </i></small>"
msgstr ""
